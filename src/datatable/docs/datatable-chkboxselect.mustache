<style scoped>
/* css to counter global site css */
.example table {
    width: auto;
}
.center { text-align: center; }
#dstatus {
   margin-top: 25px;
   background-color: #0c0;
   width: 420px;
}

#processed {
    color: #00c;
}
.myCheckboxFmtr, .myCheckboxALL {
    cursor: pointer;
}
</style>

<div class="intro">
    <p>A method of selecting certain records using the familiar "checkbox" HTML input control is demonstrated in this example.</p>
</div>

<div class="example yui3-skin-sam">
    <div id="template" class="yui3-skin-sam dt-example">
            <div id="dtable"></div>
            <button id="btnSelected" class="yui3-button">Process Selections</button>
            <button id="btnClearSelected" class="yui3-button">Clear Selections</button>

            <div id="dstatus">The following check selected records were processed;
                <div id="processed">None.</div>
            </div>
    </div>
    {{>datatable-chkboxselect-source}}
</div>

<h2>Sample Data</h2>

<p>This example will use a local Javascript array of data that includes some common Internet port socket numbers and protocol names;</p>
```
var ports = [
    { port:20,  pname:'FTP_data',ptitle:'File Transfer Process Data' },
    { port:21,  pname:'FTP',     ptitle:'File Transfer Process' },
    { port:22,  pname:'SSH',     ptitle:'Secure Shell' },
    { port:23,  pname:'TELNET',  ptitle:'Telnet remote communications' },
    ... // data continues
];
```

<h2>The DataTable</h2>

<p>Our DataTable for this example will utilize a custom formatter as the first column, to display a standard HTML INPUT[type=checkbox] element as an indication
 that the record is desired to be "selected" for additional processing.  But that checkbox won't work on it's own, because if a "sort" action happens after
 the checkbox is clicked the "check" status is lost!.</p>

<p>A way to get around this is to create a binding of the "checkbox" to an attribute of <b>each record</b> which will remain with the record even upon
sorts, edits, or other modifications to the record.  This is accomplished by defining a custom `recordType` for the DataTable that incorporates all of our
 standard `data` for our table but also defines a new Attribute (called `select` here) that is a boolean value to track whether the record is selected.
</p>

<p>The implementation of these methods is shown below, where we have defined a custom formatter that creates a "checkbox" for the first column, and defines a custom
`recordType` with our new Attribute added.  Additionally, we incorporate (a) scrolling and (b) sorting to demonstrate that this technique works.</p>

```
var dt = new Y.DataTable({
    columns : [
        {   key:        'select',
            label:      'Select <input type="checkbox" class="classSelALL" title="Click to toggle ALL records"/>',
            allowHTML:  true,   // must use this if we insert HTML in the label AND the formatter!

            formatter:  function(o) {
                            var chkd = (o.data.select) ? "checked" : "";
                            o.value = '<input type="checkbox" class="myCheckboxFmtr" ' + chkd + '/>';
                            o.className += ' center';
                         }
        },
        {   key:'port',   label:'Port No.' },
        {   key:'pname',  label:'Protocol' },
        {   key:'ptitle', label:'Common Name' }
    ],
    data :      ports,
    scrollable: 'y',
    height:     '300px',
    sortable :  ['port','pname'],
    recordType: {
        select: { value:false },     // a custom property ... defined to allow "checkbox" select to work easily !
        port:{}, pname:{},  ptitle:{}
    }
}).render("#dtable");
```

<h2>The 'checkbox' Listeners</h2>
<p>Having a DataTable with a bunch of checkboxes in it may look cool (or not!), but we also need to define what to do when they
are checked.   Since the column formatter for the first column creates the checkboxes, we will use Delegate on the DataTable container
   to listen to any check "click" events.  (Some implementers may have defined a listener on each checkbox, which is a really
   bad practice ... the source of memory leaks, and just plain awkward!).
</p>
<p>

</p>

```
// Define a listener on the DT first column for each record's "checkbox",
//   to set the value of `select` to the checkbox setting
dt.delegate("click",function(e){
    var chk = e.target,             // this is the INPUT[type='checkbox'] Node
        td  = chk.ancestor(),       // since e.target is on INPUT, parent is the containing TD
        rec = this.getRecord(td);   // we need the "record" (i.e. Model of the data)

    rec.set('select', chk.get('checked') ); // updates the 'selected' attribute
},".myCheckboxFmtr", dt);

// Also define a listener on the single TH "checkbox" to
//   toggle all of the checkboxes
Y.one(".myCheckboxALL").on("click", function(e){
    var chk = e.target.get('checked');      // gets the checked status
    this.get('data').each(function(item){
        item.set('select',chk);             // sets each record's `select` to this
    });
},dt);
```

<h2>Button 'click' Handlers</h2>

<p>The bulk of the nitty-gritty is done now.   We'll just define some css-button click handlers to
process through the "checked" records and one to allow us to clear all the selections.</p>
```
Y.one("#btnSelected").on("click",function(){
    var ml  = this.get('data'),
        msg = '';

    ml.each(function(item){
        if ( item.get('select') )
            msg += "Record index = " + ml.indexOf(item)
                    + ' Data = ' + item.get('port') + ' : ' + item.get('pname') + '<br/>';
    });

    msg = ( msg.length === 0 ) ? 'None selected!' : msg;    // if no selections, null the 'msg' variable

    Y.one("#processed").setContent( msg );

}, dt);

Y.one("#btnClearSelected").on("click",function(){
    var ml  = this.get('data');

    ml.each(function(item){
        item.set('select',false);
    });

    Y.one("#processed").setContent('Cleared.');

}, dt);
```

<p>Note that if we were certain that all clients were using a CSS3 compliant browser, it would be really
easy to simply get the "checked" records using `dt.get("srcNode").all("input.myCheckboxFmtr:checked");`,
 but as we all know ... that isn't always assured.</p>

<p>Another improvement that could be made for HTML5 compliant clients would be the ability to add in `localStorage`
access to save the "checked" record data to the browser environment.   See for example the Y.App ToDo example.</p>


<h2>Full Source Code</h2>

<h3>CSS</h3>
```
.center { text-align: center; }

.myCheckboxFmtr, .myCheckboxALL { cursor: pointer; }

#dstatus {
   margin-top: 25px;
   background-color: #0c0;
   width: 420px;
}

#processed {
    color: #00c;
}
```

<h3>HTML Markup</h3>
```
<div id="dtable"></div>
<button id="btnSelected" class="yui3-button">Process Selections</button>
<button id="btnClearSelected" class="yui3-button">Clear Selections</button>

<div id="dstatus">The following check selected records were processed;
    <div id="processed">None.</div>
</div>
```

<h3>Javascript</h3>
```
{{>datatable-chkboxselect-source}}
```
