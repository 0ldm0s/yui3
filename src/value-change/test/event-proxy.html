<!DOCTYPE html>
<html>
<head>
<title>investigating this scope in custom node events</title>

<link rel="stylesheet" href="http://yui.yahooapis.com/3.0.0b1/build/cssfonts/fonts-min.css">
<style>
body {
    font-size:16px;
}
.demoified {
    font-size:200%;
    border:10px solid red;
}
script.mine {
    clear:left;
    white-space:pre;
    display:block;
    font-family:monospace;
    background:#eef;
}
script::before, script::after {
    content:"<script>";
}
script::after {
    content:"</script>";
}
script[src]::before {
    content:"<script src=\"" attr(src) "\">";
    white-space:nowrap;
}
script[src] {
    background:#fff;
}
</style>

</head>
<body>
<input class="input" value="change me!" size="100"><br>
<button id="doit">do it</button>

<ol>
	<li>Create a custom event name, which the listener is attached to.</li>
	<li>Listen to a DOM event, and have the listener fire the CE.</li>
	<li>When the CE handlers are all removed, remove the DOM event handlers.</li>
	<li>If the DOM event handlers are removed, remove the CE handler.</li>
</ol>


<script class="mine" src="../../../build/yui/yui.js"></script>
<script>
function logger () {
	console.log.apply(console, arguments);
	return logger;
};
function logThis () {
	logger("logThis!");
	// logger(this)(arguments);
};
</script>

<script>
YUI.add("event-proxy", function (Y) {

/**
 * A way to yoke multiple events into a single custom event proxy, and then
 * expose a new event name as a way to assign listeners to it.
 **/

/**
 * Take a selector string, or a node, or a domnode, or a nodelist, or an array of domnodes,
 * and return a nodelist.
 **/
function toNodeList (el) {
	if (Y.Lang.isString(el)) return Y.all(el);
	if (Y.Lang.isArray(el)) return Y.all(el);
	if (el instanceof Y.Node) return Y.all([el._node]);
	if (el instanceof Y.NodeList) return el;
	return Y.all([el]);
};

Y.EventProxy = function EventProxy (o) {
	// if it's already been built, then return the one that's already there.
	if (o.name in Y.Env.evt.plugins) return Y.Env.evt.plugins[o.name];
	
	// switch into ctor mode.
	if (!(this instanceof Y.EventProxy)) return new Y.EventProxy(o);
	
	this.eventName = o.name;
	this.trigger = Y.Lang.isArray(o.trigger) ? o.trigger : [o.trigger];
	
	// make it real.
	Y.Node.DOM_EVENTS[this.eventName] = Y.Env.evt.plugins[this.eventName] = this;
};

Y.EventProxy.prototype.detach = function () {
	// TODO: promise needs to be node-specific! not on the event object itself!
	// What if we have a bunch all waiting to be attached to different nodes!??!
	if (this.promise) {
		// just remove the onAvailable handler, if we happen to still be waiting for it.
		var p = this.promise;
		this.promise = null;
		return p.detach.apply(this.promise, arguments);
	}
	
	// remove all the listeners we added before.
	// clean out the private registry or whatever.
};

function bindApply (fn, o, args) {
	args = Y.Array(args,0);
	return function () {
		return fn.apply(o, args.concat(Y.Array(arguments,0)));
	};
};

Y.EventProxy.prototype.on = function (ev, fn, el, o) {
	
	// first, normalize the element to a nodelist.
	var target = toNodeList(el);
	
	// handle empty selector lists using onAvailable.
	if (Y.Lang.isString(el) && target.size() === 0) {
		this.promise = Y.Event.onAvailable(el, bindApply(Y.EventProxy.prototype.on, this, arguments));
		return this;
	}
	
	// at this point, assume that any promises have been fulfilled.
	if (this.promise) this.promise = null;
	
	// do this for each node in the list.
	target.each(attacher(arguments), this);
	
	return this;
};

function attacher (args) {
	args = Y.Array(args, 0);
	var self = this,
		ev = args.shift(),
		fn = args.shift(),
		el = args.shift(),
		o = args.shift();
		// now args is JUST the extra bits and bobs.
	
	return function (node) {
		// create the proxy event name
		var proxyName = self.proxyName(node);
		
		// if this node hasn't already been set up, then attach the appropriate triggers.
		// Listen to a DOM event, and have the listener fire the CE.
		// If all the DOM event handlers are removed, remove the CE handler.
		if (!node.getEvent(proxyName)) {
			attachTriggers.call(self, node);
		}
		
		// attach the fn to the proxyName event
		// append the rest of the args to the three that matter most.
		var proxyHandle = node.on.apply(node, [proxyName, fn, o || node].concat(args));
		
		// When the CE handlers are all removed, remove the DOM event handlers.
		Y.after("detach", function () {
			removeTriggers.call(self, node);
		}, proxyHandle);
	};
};

Y.EventProxy.prototype.proxyName = function (node) {
	return Y.stamp(node) + "-" + this.eventName;
};

// private member of the EventProxy class.
// attach the triggers to the node.
function attachTriggers (node) {
	// attach listeners to node for all of the events in the this.trigger array
	// the handler should call this.proxyFn, supplying it with a context object
	// and a "fire" function that, when called, fires the proxied event, triggering
	// the user functions appropriately.
	
	// if the triggers are all removed, then detach the proxy CE as well.

	// add to a registry so that we know triggers have been attached.
};

// private member of the EventProxy class.
// remove the triggers, and (if it's not been done already) detach the proxy
function removeTriggers (node) {
	// if it's in the registry, then remove it, call detach, and abort.
	// the second pass will remove the triggers themselves, if it's not cancelled.
	// for each of the trigger handlers, call detach() to remove them.
};


}, '@VERSION@' ,{requires:['node-base']});

</script>

<script>
YUI.add("value-change", function (Y) {
	
	var getListener = (function () {
		var listeners = {};
		return function getListener (key) {
			return listeners.hasOwnProperty(key)
				? listeners[key] 
				: (listeners[key] = { value : null, timeout : null });
		};
	})();
	
	Y.EventProxy({
		name : "valueChange",
		trigger : [ "change", "keypress", "paste", "keydown" ],
		proxyFn : function (context, fire) {
			var target = context.target;
			var key = Y.stamp(target);
			var listener = getListener(target);
			if (listener.timeout) listener.timeout.cancel();
			listener.timeout = Y.later(10, this, function () {
				// if the value is different, then execute!
				var currentValue = target.get("value"), oldValue = listener.value;
				listener.value = currentValue;				
				if (currentValue !== oldValue) fire();
			});
		}
	});
	
}, '@VERSION@', {requires:['event-proxy']});


// testy test code below.
YUI({
    debug: true,
    base : "../../../build/",
    filter : "raw"
}).use('custom-dom', function (Y) {
	
	window.Y=Y;
	
	console.info("Y.all('.input').on('customDom', logger)");
	console.log(Y.all(".input").on("customDom", logThis));

	console.info("Y.one('.input').on('customDom', logger)");
	console.log(Y.one(".input").on("customDom", logThis));
	
	console.info("Y.on('customDom', logger, '.input')");
	console.log(Y.on("customDom", logThis, ".input"));
	
	console.info("Y.on('customDom', logger, Y.all('.input'))");
	console.log(Y.on('customDom', logThis, Y.all('.input')));

	Y.one("#doit").on("click", function () {
		logger("clicky!");
		var i = Y.one(".input");
		i.fire("customDom", {
			type : "customDom",
			target : i,
			currentTarget : i
		});
		logger("fired");
	});
	
});
</script>
</body>
</html>
