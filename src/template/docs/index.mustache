<div class="intro">
<p>
The Template component provides `Y.Template`, a generic template engine API, and `Y.Template.Micro`, a string-based micro-templating language similar to <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/erb/rdoc/ERB.html">ERB</a> and <a href="http://underscorejs.org/#template">Underscore</a> templates.
</p>
</div>

{{>getting-started}}

<h2>Using `Template`</h2>

<h3>Quick Start</h3>

<p>
A template engine takes a template&mdash;usually in the form of a string&mdash;and some data, and renders the data into the template to produce an HTML or text string. Using templates to keep markup and structure separate from content encourages reuse and can make code easier to read and maintain, and in many cases faster.
</p>

<p>
`Y.Template` provides a common API that can be used to compile and render templates with a variety of template engines. The two template engines included in YUI are <a href="../handlebars/index.html">Handlebars</a> and [[#Using Template.Micro|Template.Micro]].
</p>

<p>
The quickest way to get started is using the `template` module which will load both the `template-base` and `template-micro` modules. The following example shows the most basic usage with the `Y.Template.Micro` engine (the default template engine):
</p>

```javascript
YUI().use('template', function (Y) {
    var micro = new Y.Template(),
        html  = micro.render('<i><%= data.message %></i>', {message: 'hello!'});

    Y.log(html); // => "<i>hello!</i>"
});
```

<p>
In the above example, `micro` is an instance of a template engine backed by Template.Micro. The `Y.Template()` constructor provides an abstraction over the backing engine, giving the engine instances a uniform API.
</p>

<p>
Handlebars templates can be used instead of Micro templates by using the `template-base` and `handlebars` modules. The following example shows how to generate the same output as the above example with the Handlebars engine:
</p>

```javascript
YUI().use('template-base', 'handlebars', function (Y) {
    var handlebars = new Y.Template(Y.Handlebars),
        html       = handlebars.render('<i>\{{message}}</i>', {message: 'hello!'});

    Y.log(html); // => "<i>hello!</i>"
});
```

<p>
<strong>Note:</strong> Both examples are using the engine's <strong>`render()`</strong> method to compile and render the template dynamically on the <strong>client</strong>, doing this with Micro templates is fine, but it should be <strong>avoided with Handlebars</strong> templates. It is recommended that Handlebars templates be <a href="../handlebars/index.html#precompiling-templates">precompiled</a>, enabling the client code to use the lighter and faster `handlebars-base` module.
</p>

<h3>Generic Template API</h3>

<p>
`Y.Template` exists to specifically to provide its API as a normalization layer on top of conceptually similar, but technically different template engines and syntaxes. This layer of abstraction allows components which work with templates to not be tied to a particular engine. Another huge benefit is allowing developers to override a component's default templates using an entirely different template engine.
</p>

<p>
The two templates engines provided in YUI, Handlebars and Template.Micro, are conceptually similar. They both compile string-based templates into functions, which are invoked with a data context and return the rendered output as a string. Handlebars is really well suited for organizing and managing the templates of an entire app or complex widget because of its partials and helpers features. Template.Micro is great for small templates, or when you need more powerful templates and its compilation engine is <em>extremely</em> small.
</p>

<p>
By making Template.Micro's public API very similar to Handlebars, we've made it possible to use the two template engines interchangeably via the `Y.Template` normalization API. When you need to compile templates on the client, it is <strong>strongly recommend</strong> that you use Micro templates, because Template.Micro's compile is <em>much</em> smaller than Handlebars' compiler &mdash; 0.5KB vs 9KB (minified and Gzipped) respectively.
</p>

<h3>Instantiating a Template Engine</h3>

<p>
While you can use a specific template engine directly, it is recommended that you create an instance of the generic `Y.Template` engine wrapper. Doing so allows for greater flexility and interoperability as described in the previous section.
</p>

<p>
To create a template engine instance, you must first determine which underlying engine you want to use. The two template engines included in YUI are <a href="../handlebars/index.html">Handlebars</a> and [[#Using Template.Micro|Template.Micro]]. If you're looking to use a different engine, refer to [[#Creating a Custom Template Engine]] section below.
</p>

<p>
Once you've determined the underlying template engine, you'll need to load the appropriate YUI module to fulfill how you plan to use templates. Refer to the following table of YUI modules to understand what each module proivdes:
</p>

<table>
    <thead>
        <tr>
            <th>Module</th>
            <th>Compiler</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td style="white-space: nowrap;">`template-base`</td>
            <td>No</td>
            <td>
                <p>
                Provides a generic API for using template engines such as `Handlebars` and `Y.Template.Micro`.
                </p>
            </td>
        </tr>
        <tr>
            <td style="white-space: nowrap;">`template-micro`</td>
            <td>Yes</td>
            <td>
                <p>
                Adds the `Y.Template.Micro` template engine, which provides fast, simple string-based micro-templating similar to ERB or Underscore templates.
                </p>
            </td>
        </tr>
        <tr>
            <td style="white-space: nowrap;">`template`</td>
            <td>Yes</td>
            <td>
                <p>
                Virtual rollup of the `template-base` and `template-micro` modules.
                </p>
            </td>
        </tr>
        <tr>
            <td style="white-space: nowrap;">`handlebars-base`</td>
            <td>No</td>
            <td>
                <p>
                Provides basic Handlebars template rendering functionality. Use this module when you only need to render pre-compiled templates.
                </p>
            </td>
        </tr>
        <tr>
            <td style="white-space: nowrap;">`handlebars-compiler`</td>
            <td>Yes</td>
            <td>
                <p>
                Handlebars parser and compiler. Use this module when you need to compile Handlebars templates.
                </p>
            </td>
        </tr>
        <tr>
            <td style="white-space: nowrap;">`handlebars`</td>
            <td>Yes</td>
            <td>
                <p>
                Virtual rollup of the `handlebars-base` and `handlebars-compiler` modules.
                </p>
            </td>
        </tr>
    </tbody>
</table>

<h4>Using Micro Templates</h4>

<p>
When working with Micro templates, it's easiest to use the `template` virtual rollup module. The `Y.Template.Micro` compiler is small enough that it is included with the runtime functionality.
</p>

<p>
The following example creates two template engine instances with are functionally equivalent and both backed by Template.Micro:
</p>

```javascript
YUI().use('template', function (Y) {
    var microExplicit, microDefault;

    // Creates a template engine instance and explicitly specifies the
    // underlying engine.
    microExplicit = new Y.Template(Y.Template.Micro);

    // Creates another template engine instance with the same functionality,
    // but relies on `Y.Template.Micro` being defined as the underlying engine
    // by default.
    microDefault = new Y.Template();
});
```

<h4>Using Handlebars Templates</h4>

<p>
When working with Handlebars templates, you'll need to determine if the need the Handlebars compiler functionality provided by the `handlebars-compiler` module. It is recommended that Handlebars templates be <a href="../handlebars/index.html#precompiling-templates">precompiled</a>, enabling the client code to use the lighter and faster `handlebars-base` module.
</p>

<p>
The following example loads only the Handlebars runtime and generic `Y.Template()` wrapper API. It assumes that all templates have previously been precompiled on the server or during a build step:
</p>

```javascript
YUI().use('template-base', 'handlebars-base', function (Y) {
    // Creates a limited template engine instance using Handlebars as the
    // underlaying engine, but with only the runtime functionality.
    var handlebars = new Y.Template(Y.Handlebars);
});
```

<p>
<strong>Note:</strong> In the above example, the `handlebars` engine does <strong>not</strong> have the ability to `render()`, `compile()`, or `precompile()` template. It only has the ability to `revive()` and execute precompiled templates.
</p>

<p>
The following example, uses the `handlebars` virtual rollup module which includes the `handlebars-compiler`. This enables the Handlebars-backed template engine instances to use the <a href="{{apiDocs}}/classes/Template.html">full API</a>:
</p>

```javascript
YUI().use('template-base', 'handlebars', function (Y) {
    // Creates a template engine instance using Handlebars as the underlaying
    // engine, with both the runtime and compiler functionality.
    var handlebars = new Y.Template(Y.Handlebars);
});
```

<h3>Compiling and Rendering Templates</h3>

<h3>Precompiling and Reviving Templates</h3>

<h3>Creating a Custom Template Engine</h3>

<p>[how to create a template engine that conforms to the `Y.Template` API interface]</p>

<h2>Using `Template.Micro`</h2>

<p>[Overview of what Template.Micro is and what kinds of use cases it's suited for -- when you'd use it vs. Handlebars, etc.]</p>

<h3>Template Syntax</h3>

<h4>Basic Expressions</h4>

<h4>HTML Escaping</h4>

<h4>Inline Code &amp; Code Blocks</h4>

<h3>Compiling and Rendering Templates</h3>

<p>[may be redundant; possibly just refer to the Y.Template section above?]</p>

<h3>Precompiling and Reviving Templates</h3>

<p>[may be redundant; possibly just refer to the Y.Template section above?]</p>

<h3>Customizing Template Syntax</h3>

<p>[describe how to override Y.Template.Micro's regexes to customize the template syntax if desired]</p>

<h2>Using Templates in Custom Components</h2>

<p>[guidelines for bundling templates with custom views, widgets, etc. -- how to build, compile, and make them available on a namespace]</p>

<h2>Best Practices</h2>

<p>[recommended best practices for templates -- don't embed too much logic, don't embed huge template strings in JS, compile once; render often, etc.]</p>
