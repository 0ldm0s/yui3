<div class="intro">
<p>
The Template component provides `Y.Template`, a generic template engine API, and `Y.Template.Micro`, a string-based micro-templating language similar to <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/erb/rdoc/ERB.html">ERB</a> and <a href="http://underscorejs.org/#template">Underscore</a> templates.
</p>
</div>

{{>getting-started}}

<h2>Using `Template`</h2>

<h3>Quick Start</h3>

<p>
A template engine takes a template&mdash;usually in the form of a string&mdash;and some data, and renders the data into the template to produce an HTML or text string. Using templates to keep markup and structure separate from content encourages reuse and can make code easier to read and maintain, and in many cases faster.
</p>

<p>
`Y.Template` provides a common API that can be used to compile and render templates with a variety of template engines. The two template engines included in YUI are <a href="../handlebars/index.html">Handlebars</a> and [[#Using Template.Micro|Template.Micro]].
</p>

<p>
The quickest way to get started is using the `template` module which will load both the `template-base` and `template-micro` modules. The following example shows the most basic usage with the `Y.Template.Micro` engine (the default template engine):
</p>

```javascript
YUI().use('template', function (Y) {
    var micro = new Y.Template(),
        html  = micro.render('<i><%= data.message %></i>', {message: 'hello!'});

    Y.log(html); // => "<i>hello!</i>"
});
```

<p>
In the above example, `micro` is an instance of a template engine backed by Template.Micro. The `Y.Template()` constructor provides an abstraction over the backing engine, giving the engine instances a uniform API.
</p>

<p>
Handlebars templates can be used instead of Micro templates by using the `template-base` and `handlebars` modules. The following example shows how to generate the same output as the above example with the Handlebars engine:
</p>

```javascript
YUI().use('template', function (Y) {
    var handlebars = new Y.Template(),
        html       = handlebars.render('<i>{{message}}</i>', {message: 'hello!'});

    Y.log(html); // => "<i>hello!</i>"
});
```

<p>
<strong>Note:</strong> Both examples are using the engine's <strong>`render()`</strong> method to compile and render the template dynamically on the client. Dynamic rendering of Micro templates is fine, but it should be <strong>avoided</strong> with <strong>Handlebars</strong> templates. It is recommended that Handlebars templates be <a href="../handlebars/index.html#precompiling-templates">precompiled</a>, enabling the client code to use the lighter and faster `handlebars-base` module.
</p>

<h3>Generic Template API</h3>

<p>
`Y.Template` exists to specifically to provide its API as a normalization layer on top of conceptually similar, but technically different template engines and syntaxes. This layer of abstraction allows components which work with templates to not be tied to a particular engine. Another huge benefit is allowing developers to override a component's default templates using an entirely different template engine.
</p>

<p>
The two templates engines provided in YUI, Handlebars and Template.Micro, are conceptually similar. They both compile string-based templates into functions, which are invoked with a data context and return the rendered output as a string. Handlebars is really well suited for organizing and managing the templates of an entire app or complex widget because of its partials and helpers features. Template.Micro is great for small templates, or when you need more powerful templates and its compilation engine is <em>extremely</em> small.
</p>

<p>
By making Template.Micro's public API very similar to Handlebars, we've made it possible to use the two template engines interchangeably via the `Y.Template` normalization API. When you need to compile templates on the client, it is <strong>strongly recommend</strong> that you use Micro templates, because Template.Micro's compile is <em>much</em> smaller than Handlebars' compiler &mdash; 0.5KB vs 9KB (minified and Gzipped) respectively.
</p>

<h3>Instantiating a Template Engine</h3>

<h3>Compiling and Rendering Templates</h3>

<h3>Precompiling and Reviving Templates</h3>

<h3>Creating a Custom Template Engine</h3>

<p>[how to create a template engine that conforms to the `Y.Template` API interface]</p>

<h2>Using `Template.Micro`</h2>

<p>[Overview of what Template.Micro is and what kinds of use cases it's suited for -- when you'd use it vs. Handlebars, etc.]</p>

<h3>Template Syntax</h3>

<h4>Basic Expressions</h4>

<h4>HTML Escaping</h4>

<h4>Inline Code &amp; Code Blocks</h4>

<h3>Compiling and Rendering Templates</h3>

<p>[may be redundant; possibly just refer to the Y.Template section above?]</p>

<h3>Precompiling and Reviving Templates</h3>

<p>[may be redundant; possibly just refer to the Y.Template section above?]</p>

<h3>Customizing Template Syntax</h3>

<p>[describe how to override Y.Template.Micro's regexes to customize the template syntax if desired]</p>

<h2>Using Templates in Custom Components</h2>

<p>[guidelines for bundling templates with custom views, widgets, etc. -- how to build, compile, and make them available on a namespace]</p>

<h2>Best Practices</h2>

<p>[recommended best practices for templates -- don't embed too much logic, don't embed huge template strings in JS, compile once; render often, etc.]</p>
