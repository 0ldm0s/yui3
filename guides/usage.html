<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>Using YUI 3.0</title>

<script type="text/javascript">

</script>
<style type="text/css">
    ol, ul, li {
        margin: 0;
        padding:0;
    }
    
    dt {
        font-weight:bold;
    }

</style>
<link rel="stylesheet" type="text/css" href="http://yui.yahooapis.com/2.5.0/build/base/base.css">
</head>
<body>
<h1>Using YUI 3.0</h1>
<h2>Table of Contents</h2>
<ol>
    <li>
        <a href="#yui">YUI Object</a>
        <ul>
            <li><a href="#yui-add">add()</a></li>
            <li><a href="#yui-use">use()</a></li>
        </ul>
    </li>
    <li>
        <a href="#events">Events</a>
    </li>
    <li>
        <a href="#node">Node</a>
        <ul>
            <li><a href="#node-static">static usage</a></li>
            <li><a href="#node-props">properties</a></li>
            <li><a href="#node-atts">attributes</a></li>
            <li><a href="#node-get">instance usage - get()</a></li>
        </ul>
    </li>
    <li><a href="#nodelist">NodeList</a></li>
    <li>
        <a href="#widget">Widget</a>
            <ul>
                <li><a href="#widget-classes">classes</a></li>
                <li><a href="#widget-extend">extending</a></li>
                <li><a href="#widget-mvc">MVC</a></li>
            </ul>
    </li>
    <li>
        <a href="#plugin">Plugin</a>
            <ul>
                <li><a href="#plugin-classes">classes</a></li>
                <li><a href="#plugin-extend">extending</a></li>
            </ul>
    </li>

<h2>Content</h2>
<ol>
    <li id="yui">
        <h3>YUI Object</h3>
        <p>In YUI 3.0 the <code>YUI</code> object replaces the <code>YAHOO</code> object.</p>

        <h4 id="yui-add">YUI.add()</h4>
        <p>The <code>YUI.add()</code> method registers a module.  As a <strong>best practice</strong>, always wrap an anonymous function around your module declaration to sandbox it.</p>
        <code><pre>

        (function() {

            var M = function(Y) {
                var Y.Node = function() {

                };

                Y.Node.get = function() {};

                Y.Node.prototype = {
                    style: function() {},
                    att: function() {}
                }
            };

            YUI.add('node', M, '3.0.0');

        })();
    
        </pre></code>
        <h4 id="yui-use">YUI.use()</h4>
        <p>The <code>YUI.use()</code> method creates a new instance of the YUI library which includes the component(s) requested, and any dependencies.  As a <strong>best practice</strong>, always wrap an anonymous function around your YUI instance to sandbox it.</p>
        <code><pre>

        (function() {

            var Y = YUI.use('node');
            Y.Node.get('#foo').style('color', 'red');

        })();
    
        </pre></code>

    </li>

    <li id="events">
        <h3>Events</h3>
        <p>In YUI 3.0, all events are implemented as Custom Events.  The signature is the same for all event types.  All event handlers recieve an Event object (facade).</p>
        <code><pre>

        (function() {

            var Y = YUI.use('node');
            Y.on('click', Y.bind(this.fn, this, arg1, arg2), el);
            Y.on('node:click', Y.bind(this.fn, this, arg1, arg2), el);

        })();
    
        </pre></code>
    </li>

    <li id="node">
        <h3>Node</h3>
        <p>The <code>Node</code> object subsumes the YAHOO.util.Dom object. It works as both a static and instantiable class.</p>
        <p>All strings passed to Node as DOM references are treated as selectors (first matching node wins).</p>
        <p>Any method that normally returns an HTMLElement returns a Node instance bound to the HTMLElement.  Any method that normally returns an HTMLCollection returns a NodeList bound to the HTMLCollection.</p>

        <h4 id="node-static">Static Usage</h4>
        <code><pre>

        (function() {

            var Y = YUI.use('node');
            Y.Node.style('#foo', 'color', 'red'); 

            Y.Node.replaceChild('#foo', '#baz', '#bar'); // returns Node instance bound to #bar 
            Y.Node.children('#foo'); // returns NodeList instance

        })();
    
        </pre></code>

        <h4 id="node-props">HTMLElement Properties</h4>
        <p>Standard HTMLElement properties are converted to methods under the Node API.  Writeable properties are overloaded as both setters and getters.</p>

        <code><pre>

        (function() {

            var Y = YUI.use('node');
            Y.Node.style('#foo', 'color');  // returns document.getElementById(foo).style.color
            Y.Node.style('#foo', 'color', 'red');  // set document.getElementById(foo).style.color = red;

            Y.Node.scrollTop('#foo');  // returns document.getElementById(foo).scrollTop
            Y.Node.scrollTop('#foo', 200);  // set document.getElementById(foo).scrollTop = 200
        })();
    
        </pre></code>

        <h4 id="node-att">HTMLElement Attributes</h4>
        <p>Standard HTMLElement attributes are available via the <code>Node.att()</code> interface.  As with the <code>Node.style()</code> method, it is overloaded as both a setter and getter.  To avoid security leaks, only valid attributes for the specific HTMLElement type are allowed (enforced via get/setAttribute).</p>

        <code><pre>

        (function() {
            var Y = YUI.use('node');
            Y.Node.att('#foo', 'title'); // returns document.getElementById(foo).getAttribute('title')
            Y.Node.att('#foo', 'title', 'i am foo'); // document.getElementById(foo).setAttribute('title', 'i am foo')
        })();

        </pre></code>
        <h4 id="node-get">Node.get()</h4>
        <p>The <code>Node.get()</code> method is used to create facades for existing HTMLElements.</p>
        <code><pre>

        (function() {

            var Y = YUI.use('node');
            var foo = Y.Node.get('#foo'); // creates a Node instance bound to #foo
            foo.style('color', 'red'); 
            foo.replaceChild('#baz', '#bar'); // returns Node instance bound to #bar 
            foo.children(); // returns NodeList instance

        })();
    
        </pre></code>

    </li>
    <li id="nodelist">
        <h3>Nodelist</h3>
        <p>The <code>NodeList</code> object provides the Node functionality across a collection of nodes.</p>
        <p>All strings passed to Node as DOM references are treated as selectors.</p>

        <code><pre>

        (function() {

            var Y = YUI.use('node');
            Y.NodeList.get('.foo').addClass('bar');

        })();
    
        </pre></code>

        <h4 id="node-props">HTMLElement Properties</h4>
        <p>Standard HTMLElement properties are converted to methods under the Node API.  Writeable properties are overloaded as both setters and getters.</p>

        <code><pre>

        (function() {

            var Y = YUI.use('node');
            Y.Node.style('#foo', 'color');  // returns document.getElementById(foo).style.color
            Y.Node.style('#foo', 'color', 'red');  // set document.getElementById(foo).style.color = red;

            Y.Node.scrollTop('#foo');  // returns document.getElementById(foo).scrollTop
            Y.Node.scrollTop('#foo', 200);  // set document.getElementById(foo).scrollTop = 200
        })();
    
        </pre></code>

        <h4 id="node-att">HTMLElement Attributes</h4>
        <p>Standard HTMLElement attributes are available via the <code>Node.att()</code> interface.  As with the <code>Node.style()</code> method, it is overloaded as both a setter and getter.  To avoid security leaks, only valid attributes for the specific HTMLElement type are allowed (enforced via get/setAttribute).</p>

        <code><pre>

        (function() {
            var Y = YUI.use('node');
            Y.Node.att('#foo', 'title'); // returns document.getElementById(foo).getAttribute('title')
            Y.Node.att('#foo', 'title', 'i am foo'); // document.getElementById(foo).setAttribute('title', 'i am foo')
        })();

        </pre></code>
        <h4 id="node-get">Node.get()</h4>
        <p>The <code>Node.get()</code> method is used to create facades for existing HTMLElements.</p>
        <code><pre>

        (function() {

            var Y = YUI.use('node');
            var foo = Y.Node.get('#foo'); // creates a Node instance bound to #foo
            foo.style('color', 'red'); 
            foo.replaceChild('#bar'); // returns Node instance bound to #bar 
            foo.children(); // returns NodeList instance

        })();
    
        </pre></code>

    </li>
    <li id="widget">
        <h3>Widget</h3>

        <h4 id="widget-classes">Class Structure and responsibilities</h4>

        <p>The <code>Widget</code> class provides the base implementation for all Widgets. It extends <code>Base</code> and therefore is an attribute provider and an event target (<code>Attribute</code> and <code>Event.Target</code> are augmented to Base.</p>
        
        <p>It provides the core functionality listed below.</p>

        <ul>
            <li>Introduces the following attributes:
                <dl>
                    <dt><code>boundingBox</code>:</dt>
                    <dd>The root <code>Node</code> instance or bounding box for the widget</dd>
                    <dt><code>contentBox</code>:</dt>
                    <dd>The <code>Node</code> instance wrapping widget content. Widgets have a double box approach to provide a consistent base for generic plugins which can be used for 
                    UI decoration (shadows, rounded corners, shims).</dd>
                    <dt><code>width, height</code>:</dt>
                    <dd>The dimensions of the bounding box for the widget</dd>
                    <dt><code>visible</code>:</dt>
                    <dd>Controls the visibility of the bounding box for the widget (through application of a widget specific class)</dd>
                    <dt><code>disabled</code>:</dt>
                    <dd>Controls the enabled/disabled state of the widget (through application of a widget specific class)</dd>
                    <dt><code>hasFocus</code>:</dt>
                    <dd>The focus state for the widget</dd>
                    <dt><code>tabIndex</code>:</dt>
                    <dd>The tabIndex to use for widget. The default implementation applies it to the bounding box of the widget.</dd>
                    <dt><code>locale</code>:</dt>
                    <dd>The current locale used to define strings for the widget</dd>
                    <dt><code>strings</code>:</dt>
                    <dd>
                        <p>
                        Localizable UI strings for the widget. NOTE: get/set for this attribute get and set the strings for the current locale ("en", "en-us" etc.). In the case of get,
                        this is without lookup support. 
                        </p>

                        <p>To retrieve strings, with lookup locale support (chaining from en-us to en to default) a getStrings(locale) method is provided as is a getString(key, locale).</p>

                        <p><strong>FUTURE DEVELOPMENT:</strong> Post PR2, we'll add a server side support also - the ability to establish a localeurl which can be used to retrieve strings from the server.</p>
                    </dd>
                </dl>
            </li>
            <li>
                Establishes <code>init</code>, <code>destroy</code> and <code>render</code> lifecycle methods which are <code>final</code>
                <dl>
                    <dt><code>init</code> <em>(inherited from <code>Base</code>)</em>:</dt>
                    <dd><p>
                        Loops through the class hierarchy, top down (Base first, sub-class last) and:
                        </p>
                        <ul>
                            <li>Configures attributes for the class, based on the ATTRS static property.</li>
                            <li>Then, invokes the <code>prototype.initializer</code> for the class.</li>
                        </ul>
                    </dd>
                </dl>
                <dl>
                    <dt><code>render</code>:</dt>
                    <dd>
                        <p>
                        Invokes the <code>renderer</code> method for the Widget instance. Unlike initializer/destructor, this is not chained automatically for the widget class hierarchy.
                        </p>
                        <p>
                        The <code>render</code> method accepts a node argument, which can be used to define where in the document the boundingBox for the widget should be appended.
                        This argument is required if the contentBox or boundingBox don't already exist in the document.
                        </p>
                    </dd>
                </dl>
                <dl>
                    <dt><code>destroy</code> <em>(inherited from <code>Base</code>)</em>:</dt>
                    <dd><p>Invokes the <code>prototype.destructor</code> for all classes in the widget hierarcy, bottom up (sub-class first, Base last).</p></dd>
                </dl>
            </li>
            <li>
                Establishes a common entry point for progressive enhancement during initialization.
                <dl>
                    <dt><code>HTML_PARSER</code></dt>
                    <dd>
                        <p><code>HTML_PARSER</code> is a prototype property, used to define a hash of selectors or functions which are responsible for looking through the content markup for the widget,
                        and extracting configuration data.</p>

<code><pre>
    MyWidget.prototype.HTML_PARSER = {
    
         titleNode: "span.yui-title",             // Set Node references using selector syntax 
         itemNodes: ["li.yui-listitem"],          // Set NodeList references using selector syntax 

         // Set other attribute types, using a parse function. Context is set to the widget instance

         label: function(contentBox) {    
            return contentBox.query("input.yui-title").get("innerHTML");
         },

         xValue: function(contentBox) {
             return contentBox.query("input.yui-slider-xvalue").get("value");
         },

         yValue: function(contentBox) {
             return contentBox.query("input.yui-slider-yvalue").get("value");
         }

    };
</pre></code>

            <p>The <code>HTML_PARSER</code> property is evaluated during Widget.prototype.initializer execution (so before Widget sub-classes recieve the user configuration),
            and the hash is iterated, to create a filled out configuration data hash for the Widget:</p>

<code><pre>
    {
        titleNode: NodeRef,
        itemNodes: NodeListRef,
        label: "My Widget",
        xValue: "10",
        yValue: "20"
    }
</pre></code>

                        <p>This hash is merged with the user config hash (PE markup is considered to be equivalent to user provided configuration), with user config data taking precedence.</p>

                        <p><strong>FUTURE DEVELOPMENT:</strong> This mechanism can be expanded to handle HTMLParser classes (for re-use/enapsulation) also, post PR2.</p>
                    </dd>
                </dl>
            </li>

            <li>
                Establishes empty methods <code>renderUI</code>, <code>bindUI</code> and <code>syncUI</code> to provide consistent entry points for rendering across all widgets.
                <dl>
                    <dt><code>renderUI</code></dt>
                    <dd>Adds elements to the document</dd>
                </dl>
                <dl>
                    <dt><code>bindUI</code></dt>
                    <dd>Sets up listeners for DOM and Custom Events to bind the rendered UI to the widget state</dd>
                </dl>
                <dl>
                    <dt><code>syncUI</code></dt>
                    <dd>Refreshes the UI state, based on the current state of the widget.</dd>
                </dl>
            </li>

            <li>Introduces methods and properties for Plugin support:
                <dl>
                    <dt><code>plug(pluginclass, config)</code></dt>
                    <dd>Adds a plugin to the widget instance, with the configuration specified.</dd>
                </dl>
                <dl>
                    <dt><code>unplug(namespace)</code></dt>
                    <dd>Removes a plugin at the attached namespace, from the widget instance.</dd>
                </dl>
                <dl>
                    <dt><code>Widget.PLUGINS</code></dt>
                    <dd>Static array of plugins to be added to the widget instance on initialization (class level plugins).</dd>
                </dl>
            </li>
        </ul>
        
        <h4 id="widget-new-in-pr2">New/Changed in PR2</h4>
        
            <ul>
                <li><h5>Attribute Related</h5>
                    <ul>
                        <li>
                            <strong><code>_set</code> method :</strong> Attribute provides a private _set method which can be used by class code, to 
                            set readOnly, writeOnce properties internally. Events will be fired.
                        </li>
                        <li>
                            <strong><code>valueFn</code> property :</strong> The static <code>ATTRS</code> property can provide a <code>valueFn</code> which
                            will allow <code>Base</code> based classes to use "this" references in order to set instance based default values. The <code>valueFn</code> has 
                            precedence over <code>value</code> if both are defined.
                        </li>
                        <li>
                            <strong><code>reset</code> method: </strong> Attribute now maintains the initial/default configuration of an Attribute (available in the <code>initValue</code> property of the 
                            <code>State</code> object). The reset method can be used to reset to this initial state. Events will be fired.
                        </li>
                        <li><strong><code>on == before</code>, <code>after == after</code></strong>, when listening for attribute state changes (this was true in PR1 also, just a note to update any Widget code accordingly).</li>
                    </ul>
                </li>
                <li><h5>Widget Specific</h5>
                    <ul>
                        <li><strong><code>node</code> attribute </strong> Changed to <code>bondingBox</code>.</li>
                        <li><strong><code>contentBox</code> attribute</strong> added</li>
                        <li><strong><code>moveStyles</code> attribute</strong> added, to move styles from the contentBox to the boundingBox. false by default.</li>
                        <li><strong><code>ClassNameManager</code> class</strong> support augmented. Helper utility to create and cache "yui-[widgetname]-[state]" format class names.</li>
                        <li><strong><code>setUI, onUI</code> methods</strong> removed.
                            <p>
                            In favor of exposing event details directly through the set method.
<code><pre>

    /* DOM handler for the focus event */
    _onFocus: function () {
        // Instead of setUI, load the attribute change event with source details
        this.set("hasFocus", true, { src: UI });
    },

    /* State change handler for hasFocus */
    _onHasFocusChange: function(evt) {
        // So that, when the attribute change is picked up we know if it was changed programmatically, or from the DOM/UI
        this._uiSetHasFocus(evt.newVal, evt.src);
    },

    /* UI update method */
    _uiSetHasFocus : function(val, src) {
        // Avoid looping back to _onFocus, if we came from there
        if (val) {
            if (src != UI) {
                boundingBox.focus();
            }
            boundingBox.addClass(this.getClassName("focus"):
        }
    }
</pre></code>
                            </p>
                        </li>
                        <li><strong><code>HTML_PARSER</code> property</strong> support/hook added.</li>
                        <li><strong><code>strings</code> attribute</strong> support, with locales, implemented.</li>
                    </ul>
                </li>
            </ul>
        </h4>

        <h4 id="widget-extend">Extending Widget</h4>

        <p>Setup your widget constructor to invoke its superclass, and set its <code>NAME</code> static property</p>

        <code><pre>
            function MyWidget(config) {
                MyWidget.superclass.constructor.apply(this, arguments);
            }

            // NAME: Used to mark the root node, with a "yui-mywidget-xxxx" classes,
            // and namespace custom events generated by the widget instance
            // Event.Target.publish("mywidget:click").

            MyWidget.NAME = "mywidget";
        </pre></code>

        <p>Setup the default attribute configuration for the Widget if any. <em>Note</em>, setters and validators for attributes should use methods on the prototype to
        do their work, to facilitate customization.</p>

        <code><pre>
            MyWidget.ATTRS = {
                foo : {
                    set: function() {
                        // Delegate to an instance method, to allow for customization.
                        return this._setFoo();
                    },
                    value: false
                },

                // No special configuration for bar.
                bar : null,
                
                foobar : {
                    valueFn : function(val) {
                        if (this.get("bar")) {
                            return someModifiedVal;
                        } else {
                            return val;
                        }
                    }
                }
            };
        </pre></code>

        <p>Setup the static <code>PLUGINS</code> array to define the default set of plugins required for your widget class if any.</p>

        <code><pre>
            MyWidget.PLUGINS = [
                // Using default configuration for the IO plugin
                Y.Plugin.IO,

                // But specify my own configuration for the Draggable plugin
                { fn:Y.Plugin.Draggable, cfg:myddconfig}
            ];
        </pre></code>

        <p>Implement the <code>initializer</code>, <code>destructor</code> and <code>renderer</code> methods for your widget (if additional initialization, destruction or rendering work is required).</p>

        <code><pre>
            var proto = {
                initializer: function(config) {
                    Y.log(this.constructor.NAME + " initializer called");
                },

                destructor : function() {
                    Y.log(this.constructor.NAME + " destructor called");
                },

                renderer : function() {
                    // Not chained automatically, need to chain manually
                    MyWidget.superclass.renderer.apply(this, arguments);

                    Y.log(this.constructor.NAME + " renderer called");
                },

                HTML_PARSER : {
                    // Setup any PE parsing required for your widget
                }
            };
        </pre></code>

        <p>And finally, extend Widget which should give you a functional widget you can instantiate within your sandbox:</p>

        <code><pre>
            Y.extend(MyWidget, Y.Widget, proto);
            Y.MyWidget = MyWidget;

            var w = new Y.MyWidget({
                boundingBox:"body > div.mywidget", 
                visible:false,
                foo:"bar"
            });

            w.render();
            w.show();
        </pre></code>

        <h4 id="widget-mvc">Separating Visual Representation</h4>

        <p>To allow for a cleaner separation between your widget's state and its visual representation 
           <em>(e.g. ColorPicker's actual rgb value vs. the fact that it's displayed in a text box as opposed to 3 dropdowns)</em>, 
           you can see if your renderer implementation can now be broken up into separate methods, to create, bind and refresh the UI.
        </p>

        <p>This will also allow for easier customization of the widget rather than having one large <em>renderer</em> method which does all three things.</p>

        <p>Using the color picker rgb UI as a concrete example:</p>

        <code><pre>
                // MyWidget prototype continued...

                renderer: function() {
                    MyWidget.superclass.renderer.apply(this, arguments);

                    this.renderUI();
                    this.syncUI();
                    this.bindUI();
                },

                // Creates UI
                renderUI : function() {
                    var rgbNode = Y.Node.create('&#60;input type="text" /&#62;');
                    this.get("contentBox").appendChild(rgbNode);
                    this._rgbNode = rgbNode;
                },

                // Binds UI
                bindUI : function() {
                    // Update rgb's UI, when rgb value changes programatically
                    this.after("rgbChanged", this._onRGBChange);

                    // Handle DOM change event on text box
                    this._rgbNode.on("change", Y.bind(this._onRGBDOMChange, this));
                },

                // Refresh UI
                syncUI: function() {
                    this._uiSetRGB(this.get("rgb"));
                },

                // Update RGB UI
                _uiSetRGB: function(val) {
                    this._rgbNode.set("value", val);
                },

                // Attribute change listener
                _onRGBChange: function(e) {
                    if (e.src != UI) {
                        this._uiSetRGB(e.newVal);
                    }
                },

                // DOM change listener
                _onRGBDOMChange: function(e) {
                    // Let attribute change know you're coming from UI
                    this.set("rgb", this.get("value"), {src: UI});
                }
        </pre></code>
    </li>

    <li id="plugin">
        <h3>Plugin</h3>

        <h4 id="plugin-classes">Class Structure and responsibilities</h4>

        <p>The <code>Y.Plugin</code> class provides the base implementation for all Plugins. It extends <code>Y.Base</code> and therefore is a <code>Y.Attribute.Provider</code> and <code>Y.Event.Target</code> (a.k.a <code>EventProvider</code>). It:</p>
        <ul>
            <li>
                Establishes <code>init</code> and <code>destroy</code> lifecycle methods which are <code>final</code>
                <dl>
                    <dt><code>init</code> <em>(inherited from <code>Y.Base</code>)</em>:</dt>
                    <dd>
                        <ul>
                            <li>Configures attributes for all classes in the plugin hierarchy, top down (Base first, sub-class last).</li>
                            <li>Invokes the <code>prototype.initializer</code> for all classes in the plugin hierarchy, top down (Base first, sub-class last).</li>
                        </ul>
                    </dd>
                </dl>
                <dl>
                    <dt><code>destroy</code> <em>(inherited from <code>Y.Base</code>)</em>:</dt>
                    <dd>Invokes the <code>prototype.destructor</code> for all classes in the plugin hierarcy, bottom up (sub-class first, Base last).</dd>
                </dl>
            </li>
            <li>Defines the static <code>NS</code> property, which is the namespace under which the Plugin instance will be attached to the owner.</li>
            <li>Sets up a reference to the Plugin's owner object, through <code>this.owner</code> during initialization.</li>
            <li>Provides <code>listen, nolisten, listenBefore, nolistenBefore</code> methods to allow plugin classes to attach listeners for events on the owner (or any other object), which will be detached when the plugin is removed/destroyed.</li>
            <li>Provides <code>addOverride, removeOverride</code> methods to allows plugin classes to replace methods on the owner (or any other object), with the original methods being restored when the plugin is removed/destroyed.</li>
        </ul>

        <h4 id="plugin-extend">Extending Plugin</h4>

        <p>Setup your plugin constructor to invoke its superclass, and set its <code>NAME</code> and <code>NS</code> static properties</p>

        <code><pre>
            function MyPlugin(config) {
                MyPlugin.superclass.constructor.apply(this, arguments);
            }

            // NAME: Used to identify the class
            MyPlugin.NAME = "myplugin";

            // NS: Used to define the namespace (featureset), added to the instance
            // There could be multiple classes capable of adding the same namespace 
            // (featureset) to a widget.
            MyPlugin.NS = "myfeature"; 
        </pre></code>

        <p>Setup the default attribute configuration for the Plugin if any, similar to Widget</p>

        <code><pre>
            MyPlugin.ATTRS = {
                foobar : {
                    set: function() {
                        // Delegate to an instance method, to allow for customization.
                        return this._setFooBar();
                    },
                    value: 20
                }
            };
        </pre></code>

        <p>Implement the <code>initializer</code> and <code>destructor</code> methods for your plugin (if additional initialization or destruction work is required).</p>

        <code><pre>
            var proto = {
                initializer: function(config) {
                    Y.log(this.constructor.NAME + " initializer called");

                    var plugin = this;
                    var widget = this.owner;

                    this.addOverride(widget, "doStuff", plugin.doStuff);
                    this.listen(widget, "fooChange", Y.bind(plugin._onFooChange, plugin));
                },

                destructor : function() {
                    Y.log(this.constructor.NAME + " destructor called");

                    // Plugin's destructor will remove overrides, listeners,
                    // in the event that the plugin is removed/destroyed.
                }
            };
        </pre></code>

        <p>And finally, extend <code>Y.Plugin</code> which should give you a functional plugin class:</p>

        <code><pre>
            Y.extend(MyPlugin, Y.Plugin, proto);
            Y.Plugin.MyPlugin = MyPlugin;
        </pre></code>

        <p>Which you can then pass to a widget instance, or register with a widget class, to instantiate:</p>

        <code><pre>
            // Class based registration
            MyWidget.PLUGINS = [
                Y.Plugin.MyPlugin
            ];

            - or - 

            MyWidget.PLUGINS = [
                {fn:Y.Plugin.MyPlugin, cfg:{foobar:10}}
            ];
        </pre></code>

        <code><pre>
            // Instance based registration
            mywidget.plug(Y.Plugin.MyPlugin);

            - or -

            mywidget.plug({
                fn:Y.Plugin.MyPlugin, 
                cfg:{foobar:10}
            });
        </pre></code>

        <p>And use:</p>

        <code><pre>
            mywidget.myfeature.doFeatureStuff();
            mywidget.myfeature.fire("featureevent");

            // over-ridden by MyFeature plugin
            mywidget.doStuff()
        </pre></code>
    </li>
</ol>
</body>
</html>
