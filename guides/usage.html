<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>Using YUI 3.0</title>

<script type="text/javascript">

</script>
<style type="text/css">

</style>
<link rel="stylesheet" type="text/css" href="http://yui.yahooapis.com/2.5.0/build/base/base.css">
</head>
<body>
<h1>Using YUI 3.0</h1>
<h2>Table of Contents</h2>
<ol>
    <li><a href="#yui">YUI Object</a></li>
    <li><a href="#event">Events</a></li>
    <li><a href="#node">Node</a></li>
    <li><a href="#nodelist">NodeList</a></li>
    <li><a href="#widget">Widget</a></li>
    <li><a href="#plugin">Plugin</a></li>

<h2>Content</h2>
<ol>
    <li id="yui">
        <h3>YUI Object</h3>
        <p>In YUI 3.0 the <code>YUI</code> object replaces the <code>YAHOO</code> object.</p>

        <h4>YUI.add()</h4>
        <p>The <code>YUI.add()</code> method registers a module.  As a <strong>best practice</strong>, always wrap an anonymous function around your module declaration to sandbox it.</p>
        <code><pre>

        (function() {

            var M = function(Y) {
                var Y.Node = function() {

                };

                Y.Node.get = function() {};

                Y.Node.prototype = {
                    style: function() {},
                    att: function() {}
                }
            };

            YUI.add('node', M, '3.0.0');

        })();
    
        </pre></code>
        <h4>YUI.use()</h4>
        <p>The <code>YUI.use()</code> method creates a new instance of the YUI library which includes the component(s) requested, and any dependencies.  As a <strong>best practice</strong>, always wrap an anonymous function around your YUI instance to sandbox it.</p>
        <code><pre>

        (function() {

            var Y = YUI.use('node');
            Y.Node.get('#foo').style('color', 'red');

        })();
    
        </pre></code>

    </li>

    <li>
        <h3>Events</h3>
    </li>

    <li>
        <h3>Node</h3>
        <p>The <code>Node</code> object subsumes the YAHOO.util.Dom object. It works as both a static and instantiable class.</p>
        <p>All strings passed to Node as DOM references are treated as selectors (first matching node wins).</p>
        <p>Any method that normally returns an HTMLElement returns a Node instance bound to the HTMLElement.  Any method that normally returns an HTMLCollection returns a NodeList bound to the HTMLCollection.</p>

        <h4>Static Usage</h4>
        <code><pre>

        (function() {

            var Y = YUI.use('node');
            Y.Node.style('#foo', 'color', 'red'); 

            Y.Node.replaceChild('#foo', '#bar'); // returns Node instance bound to #bar 
            Y.Node.children('#foo'); // returns NodeList instance

        })();
    
        </pre></code>

        <h4>HTMLElement Properties</h4>
        <p>Standard HTMLElement properties are converted to methods under the Node API.  Writeable properties are overloaded as both setters and getters.</p>

        <code><pre>

        (function() {

            var Y = YUI.use('node');
            Y.Node.style('#foo', 'color');  // returns document.getElementById(foo).style.color
            Y.Node.style('#foo', 'color', 'red');  // set document.getElementById(foo).style.color = red;

            Y.Node.scrollTop('#foo');  // returns document.getElementById(foo).scrollTop
            Y.Node.scrollTop('#foo', 200);  // set document.getElementById(foo).scrollTop = 200
        })();
    
        </pre></code>

        <h4>HTMLElement Attributes</h4>
        <p>Standard HTMLElement attributes are available via the <code>Node.att()</code> interface.  As with the <code>Node.style()</code> method, it is overloaded as both a setter and getter.  To avoid security leaks, only valid attributes for the specific HTMLElement type are allowed (enforced via get/setAttribute).</p>

        <code><pre>

        (function() {
            var Y = YUI.use('node');
            Y.Node.att('#foo', 'title'); // returns document.getElementById(foo).getAttribute('title')
            Y.Node.att('#foo', 'title', 'i am foo'); // document.getElementById(foo).setAttribute('title', 'i am foo')
        })();

        </pre></code>
        <h4>Node.get()</h4>
        <p>The <code>Node.get()</code> method is used to create facades for existing HTMLElements.</p>
        <code><pre>

        (function() {

            var Y = YUI.use('node');
            var foo = Y.Node.get('#foo'); // creates a Node instance bound to #foo
            foo.style('color', 'red'); 
            foo.replaceChild('#bar'); // returns Node instance bound to #bar 
            foo.children(); // returns NodeList instance

        })();
    
        </pre></code>

        <h4>Open Questions</h4>
        <ul>
            <li>Should the private DOM methods that work directly with HTMLElements be exposed to insecure environment?</li>
        </ul>
    </li>
    <li id="widget">
        <h3>Widget</h3>

        <h4>Class Structure and responsibilities</h4>

        <p>The <code>Y.Widget</code> class provides the base implementation for all Widgets. It extends <code>Y.Base</code> and therefore is a <code>Y.Attribute.Provider</code> and <code>Y.Event.Target</code> (a.k.a <code>EventProvider</code>). It:</p>

        <ul>
            <li>Introduces the following base attributes:
                <dl>
                    <dt><code>root</code>:</dt>
                    <dd>The root <code>Y.Node</code> instance or bounding box for the widget</dd>
                    <dt><code>width, height</code>:</dt>
                    <dd>The dimensions of the bounding box for the widget</dd>
                    <dt><code>visible</code>:</dt>
                    <dd>Controls the visibility of the bounding box for the widget (through application of a <code>yui-hidden</code> class)</dd>
                    <dt><code>disabled</code>:</dt>
                    <dd>Controls the enabled/disabled state of the widget (through application of a <code>yui-disabled</code> class)</dd>
                    <dt><code>strings</code>:</dt>
                    <dd>Localizable UI strings for the widget - currently an empty stub</dd>
                </dl>
            </li>
            <li>
                Establishes <code>init</code>, <code>destroy</code> and <code>render</code> lifecycle methods which are <code>final</code>
                <dl>
                    <dt><code>init</code> <em>(inherited from <code>Y.Base</code>)</em>:</dt>
                    <dd>
                        <ul>
                            <li>Configures attributes for all classes in the widget hierarchy, top down (Base first, sub-class last).</li>
                            <li>Invokes the <code>prototype.initializer</code> for all classes in the widget hierarchy, top down (Base first, sub-class last).</li>
                        </ul>
                    </dd>
                </dl>
                <dl>
                    <dt><code>render</code>:</dt>
                    <dd>Invokes the <code>renderer</code> method for the Widget instance. Not chained automatically for the widget class hierarchy.</dd>
                </dl>
                <dl>
                    <dt><code>destroy</code> <em>(inherited from <code>Y.Base</code>)</em>:</dt>
                    <dd>Invokes the <code>prototype.destructor</code> for all classes in the widget hierarcy, bottom up (sub-class first, Base last).</dd>
                </dl>
            </li>
            <li>
                Establishes empty abstract methods <code>renderUI</code>, <code>bindUI</code> and <code>syncUI</code> to provide consistent entry points for rendering across all widgets.
                <dl>
                    <dt><code>renderUI</code></dt>
                    <dd>Adds elements to the document</dd>
                </dl>
                <dl>
                    <dt><code>bindUI</code></dt>
                    <dd>Sets up listeners for DOM and Custom Events to bind the rendered UI to the widget state, with the help of <code>onUI</code></dd>
                </dl>
                <dl>
                    <dt><code>syncUI</code></dt>
                    <dd>Refreshes the UI state, based on the current state of the widget.</dd>
                </dl>
            </li>
            <li>Introduces methods and properties for Plugin support:
                <dl>
                    <dt><code>plug(pluginclass, config)</code></dt>
                    <dd>Adds a plugin to the widget instance, with the configuration specified.</dd>
                </dl>
                <dl>
                    <dt><code>unplug(namespace)</code></dt>
                    <dd>Removes a plugin at the attached namespace, from the widget instance.</dd>
                </dl>
                <dl>
                    <dt><code>Widget.PLUGINS</code></dt>
                    <dd>Static array of plugins to be added to the widget instance on initialization (class level plugins).</dd>
                </dl>
            </li>
        </ul>

        <h4>Extending Widget</h4>

        <p>Setup your widget constructor to invoke its superclass, and set its <code>NAME</code> static property</p>

        <code><pre>
            function MyWidget(config) {
                MyWidget.superclass.constructor.apply(this, arguments);
            }

            // NAME: Used to mark the root node, with a "yui-mywidget" class,
            // and namespace custom events generated by the widget instance
            // Event.Target.publish("mywidget:click"). Potentially also for
            // Y.create("mywidget") once implemented.

            MyWidget.NAME = "mywidget";
        </pre></code>

        <p>Setup the default attribute configuration for the Widget if any. <em>Note</em>, setters and validators for attributes should use methods on the prototype to
        do their work, to facilitate customization.</p>

        <code><pre>
            MyWidget.ATTRS = {
                foo : {
                    set: function() {
                        // Delegate to an instance method, to allow for customization.
                        return this._setFoo();
                    },
                    value: false
                },

                // No special configuration for bar.
                bar : null
            };
        </pre></code>

        <p>Setup the static <code>PLUGINS</code> array to define the default set of plugins required for your widget class if any.</p>

        <code><pre>
            MyWidget.PLUGINS = [
                // Using default configuration for the IO plugin
                Y.Plugin.IO,

                // But specify my own configuration for the Draggable plugin
                { fn:Y.Plugin.Draggable, cfg:myddconfig}
            ];
        </pre></code>

        <p>Implement the <code>initializer</code>, <code>destructor</code> and <code>renderer</code> methods for your widget (if additional initialization, destruction or rendering work is required).</p>

        <code><pre>
            var proto = {
                initializer: function(config) {
                    Y.log(this.constructor.NAME + " initializer called");
                },

                destructor : function() {
                    Y.log(this.constructor.NAME + " destructor called");
                },

                renderer : function() {
                    // Not chained automatically, need to chain manually
                    MyWidget.constructor.superclass.apply(this, arguments);

                    Y.log(this.constructor.NAME + " renderer called");
                }
            };
        </pre></code>

        <p>And finally, extend Widget which should give you a functional widget you can instantiate within your sandbox:</p>

        <code><pre>
            Y.extend(MyWidget, Y.Widget, proto);
            Y.MyWidget = MyWidget;

            var w = new Y.MyWidget({
                root:"body > div.mywidget", 
                visible:false,
                foo:"bar",
            });

            w.render();
            w.show();
        </pre></code>

        <h4>Separating Visual Representation</h4>

        <p>To allow for a cleaner separation between your widget's state and its visual representation 
           <em>(e.g. ColorPicker's actual rgb value vs. the fact that it's displayed in a text box as opposed to 3 dropdowns)</em>, 
           you can see if your renderer implementation can now be broken up into separate methods, to create, bind and refresh the UI.
        </p>

        <p>This will also allow for easier customization of the widget rather than having one large <em>renderer</em> method which does all three things.</p>

        <p>Using the color picker rgb UI as a concrete example:</p>

        <code><pre>
                // MyWidget prototype continued...

                renderer: function() {
                    MyWidget.constructor.superclass.apply(this, arguments);

                    this.renderUI();
                    this.syncUI();
                    this.bindUI();
                },

                // Creates UI
                renderUI : function() {
                    var rgbNode = Y.Node.create(['input', { 'type': 'text' }]);
                    this._root.appendChild(rgbNode);
                    this._rgbNode = rgbNode;
                },

                // Binds UI
                bindUI : function() {
                    // Update rgb's UI, when rgb value changes programatically
                    this.onUI("rgbChanged", Y.bind(this._uiSetRGB, this));

                    // Handle DOM change event on textbox
                    this._rgbNode.on("change", Y.bind(this._onRGBNodeChange, this));
                },

                // Refresh UI
                syncUI: function() {
                    this._uiSetRGB();
                },

                // Set RGB UI from state value
                _uiSetRGB: function() {
                    this._rgbNode.att("value", this.get("rgb"));
                },

                // Set state from RGB UI update
                _onRGBNodeChange: function(e) {

                    // e is the Y.Event facade, not a real DOM Event
                    // t is the Y.Node facade, not a real HTML Element
                    var t = e.target;

                    // Use setUI, as opposed to set, to stop looping back to update UI.
                    this.setUI("rgb", t.att("value"));
                }
        </pre></code>
    </li>

    <li id="plugin">
        <h3>Plugin</h3>

        <h4>Class Structure and responsibilities</h4>

        <p>The <code>Y.Plugin</code> class provides the base implementation for all Plugins. It extends <code>Y.Base</code> and therefore is a <code>Y.Attribute.Provider</code> and <code>Y.Event.Target</code> (a.k.a <code>EventProvider</code>). It:</p>
        <ul>
            <li>
                Establishes <code>init</code> and <code>destroy</code> lifecycle methods which are <code>final</code>
                <dl>
                    <dt><code>init</code> <em>(inherited from <code>Y.Base</code>)</em>:</dt>
                    <dd>
                        <ul>
                            <li>Configures attributes for all classes in the plugin hierarchy, top down (Base first, sub-class last).</li>
                            <li>Invokes the <code>prototype.initializer</code> for all classes in the plugin hierarchy, top down (Base first, sub-class last).</li>
                        </ul>
                    </dd>
                </dl>
                <dl>
                    <dt><code>destroy</code> <em>(inherited from <code>Y.Base</code>)</em>:</dt>
                    <dd>Invokes the <code>prototype.destructor</code> for all classes in the plugin hierarcy, bottom up (sub-class first, Base last).</dd>
                </dl>
            </li>
            <li>Defines the static <code>NS</code> property, which is the namespace under which the Plugin instance will be attached to the owner.</li>
            <li>Sets up a reference to the Plugin's owner object, through <code>this.owner</code> during initialization.</li>
            <li>Provides <code>listen, nolisten, listenBefore, nolistenBefore</code> methods to allow plugin classes to attach listeners for events on the owner (or any other object), which will be detached when the plugin is removed/destroyed.</li>
            <li>Provides <code>addOverride, removeOverride</code> methods to allows plugin classes to replace methods on the owner (or any other object), with the original methods being restored when the plugin is removed/destroyed.</li>
        </ul>

        <h4>Extending Plugin</h4>

        <p>Setup your plugin constructor to invoke its superclass, and set its <code>NAME</code> and <code>NS</code> static properties</p>

        <code><pre>
            function MyPlugin(config) {
                MyPlugin.superclass.constructor.apply(this, arguments);
            }

            // NAME: Used to identify the class
            MyPlugin.NAME = "myplugin";

            // NS: Used to define the namespace (featureset), added to the instance
            // There could be multiple classes capable of adding the same namespace 
            // (featureset) to a widget.
            MyPlugin.NS = "myfeature"; 
        </pre></code>

        <p>Setup the default attribute configuration for the Plugin if any, similar to Widget</p>

        <code><pre>
            MyPlugin.ATTRS = {
                foobar : {
                    set: function() {
                        // Delegate to an instance method, to allow for customization.
                        return this._setFooBar();
                    },
                    value: 20
                }
            };
        </pre></code>

        <p>Implement the <code>initializer</code> and <code>destructor</code> methods for your plugin (if additional initialization or destruction work is required).</p>

        <code><pre>
            var proto = {
                initializer: function(config) {
                    Y.log(this.constructor.NAME + " initializer called");

                    var plugin = this;
                    var widget = this.owner;

                    this.addOverride(widget, "doStuff", plugin.doStuff);
                    this.listen(widget, "fooChange", Y.bind(plugin._onFooChange, plugin));
                },

                destructor : function() {
                    Y.log(this.constructor.NAME + " destructor called");

                    // Plugin's destructor will remove overrides, listeners,
                    // in the event that the plugin is removed/destroyed.
                }
            };
        </pre></code>

        <p>And finally, extend <code>Y.Plugin</code> which should give you a functional plugin class:</p>

        <code><pre>
            Y.extend(MyPlugin, Y.Plugin, proto);
            Y.Plugin.MyPlugin = MyPlugin;
        </pre></code>

        <p>Which you can then pass to a widget instance, or register with a widget class, to instantiate:</p>

        <code><pre>
            // Class based registration
            MyWidget.PLUGINS = [
                Y.Plugin.MyPlugin
            ];

            - or - 

            MyWidget.PLUGINS = [
                {fn:Y.Plugin.MyPlugin, cfg:{foobar:10}}
            ];
        </pre></code>

        <code><pre>
            // Instance based registration
            mywidget.plug(Y.Plugin.MyPlugin);

            - or -

            mywidget.plug({
                fn:Y.Plugin.MyPlugin, 
                cfg:{foobar:10}
            });
        </pre></code>

        <p>And use:</p>

        <code><pre>
            mywidget.myfeature.doFeatureStuff();
            mywidget.myfeature.fire("featureevent");

            // over-ridden by MyFeature plugin
            mywidget.doStuff()
        </pre></code>
    </li>
</ol>
</body>
</html>