<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html debug="true">
<head>
<title>YUI 3.0</title>
<script type="text/javascript" src="../../build3x/yui/yui-debug.js"></script>

<body>

<input id="button1" type="button" value="Button 1" class='button' />
<input id="button2" type="button" value="Button 2" class='button' />
<input id="text1" type="text" value="something" class='nothing' />

<script>

(function() {

    var Y = YUI().use('dump', 'substitute');

    Y.on('yui:log', function(msg) {
        var d=document, b=d.body, n=d.createElement("div");
        if (b) {
            n.appendChild(d.createTextNode(msg));
            b.appendChild(n);
        }
    });


/*

Event.Target hasEvent replaced with getEvent

Event.Custom constructor signature is now type and options --- 
removed context and silent as arguments in the constructor, now these
must be passed into the config.

Added 'defaultFn' custom event property

Added 'emitFacade' config that publish() can use to use the Event.Facade signature.
This is in place until we can configure Event.Target to always produce events
with the Event.Facade signature.

When the facade in place, if the first argument is an object, these properties are
mixed into the event facade.  This provides some transparency to events that are
already being used this way, and makes it so that the consumer can use well known
property names rather than e.details[1]

*/

        // o1.addTarget(o3);

    var Base = function() {
        Y.log('Base constructor executed');
        arguments.callee.superclass.constructor.apply(this, arguments);
    }

    Y.extend(Base, Y.Event.Target, {
        base: function() {
            Y.log('all your base...');
        }
    });

    var O = function() {
        Y.log('O constructor executed');
    }

    O.prototype = {
        oOo: function(ok) {
            Y.log('oOo');
        }
    }


    Y.augment(O, Base, null, null, {
    // Y.augment(O, Y.Event.Target, null, null, {
        emitFacade: true
    });

    // augmented class
    var o1 = new O();

    // event target instance or subclass
    // var o2 = new Y.Event.Target();
    var o2 = new O();

    // augmented object
    var o3 = new Object();
    Y.augment(o3, Y.Event.Target, null, null, {
        emitFacade: true
    });

    o1.publish('o:1', {
        defaultFn: function() {
            Y.log('1 DEFAULT FN');
        } 
        // , emitFacade: true
    });

    o2.publish('o:1', {
        defaultFn: function() {
            Y.log('2 DEFAULT FN');
        } 
        // , emitFacade: true
    });

    o1.publish('chain', {
        defaultFn: function() {
            Y.log('DEFAULT FN CHAIN');
        } 
        // , emitFacade: true
    });

    o1.addTarget(o2);


    // o2.addTarget(o3);

    o1.subscribe('o:1', function(e) {
        Y.log('o1, o:1: ' + Y.Lang.dump(Y.Array(arguments)));
        this.fire('chain', 1, 2);
        // e.halt();
    });

    o1.subscribe('chain', function(e) {
        Y.log('o1, chain o1' + Y.Lang.dump(Y.Array(arguments)));
    });

    o2.subscribe('o:1', function(e) {
        Y.log('o2, o:1 from o1: ' + Y.Lang.dump(Y.Array(arguments)));
        e.halt();
    });

    o2.subscribe('chain', function(e) {
        Y.log('o2, chain from o1: ' + Y.Lang.dump(Y.Array(arguments)));
    });

    /*

    o3.subscribe('o:1', function(e) {
        Y.log('o1 to o3: ' + Y.Lang.dump(Y.Array(arguments)));
    });


    o3.subscribe('o:2', function(e) {
        Y.log('o2 to o3: ' + Y.Lang.dump(Y.Array(arguments)));
    });
    */

    // with facade
    o1.fire('o:1', {

        foo: 1,
        bar: "absorbed from fire arg 0"

    }, 2, 3);

    (o1 && o1['base'] && o1.base());


    // without facade
    //o1.fire('o:2', 4, 5, 6);


})();


</script>

</body>
</html>
