
YAHOO.env.ua -> Y.ua

YAHOO.util.Dom.get -> Y.get

YAHOO.util.Connect.asynchRequest -> Y.io
YAHOO.util.Connect.* -> Y.io.*

EventProvider -> Y.Event.Target

new YAHOO.util.CustomEvent()

EventProvider.createEvent -> Event.Target.publish

Y.publish('category:type') // global

Y.augment(Class, Y.Event.Target);
var instance = new Class();
instance.publish('type')

lang.augmentProto -> Y.augment
lang.augmentObject -> Y.mix

createEvent -> publish
fireEvent -> fire

addListener(el, type, fn, data, context) ->

    Y.on(type, fn, el, data, context) // this works now, but

    Y.on(type, fn, el) // this is what we are aiming at

    Y.on('click', Y.bind(this.fn, this, data, data), el);

removeListener(el, type, fn, data, context) ->

    Y.detach(type, fn, el, data, context) // this works now, but
    Y.detach(handle) // this is what we are aiming at

-------------------------------------------------------------------------------------

- Use your intstance to sandbox your app.

var Y = YUI();

- Pass an object for global configuration params (loader config, etc)

var Y = YUI(o);

- targeting windows/frames

var Y = YUI(o);

var frameY = YUI({
    win: frame1
};

- You must specify what you will use.

var Y = YUI().use('anim', 'dragdrop');

- You can ask it to load everything it knows about.

var Y = YUI().use('*');

- When possible, core methods return the reference to the YUI instance to allow chaining.

var Y = YUI().use('anim').use('dragdrop);

- It will be able to pull in loader to get all dependencies.

var Y = YUI().use('editor');

- Dynamic loading means the app logic must wait until the YUI instance is done getting stuff

var Y = YUI().use('editor').ready(init);

- Factory method for object creation

var Y = YUI().use('menu', 'tab').ready(function(Y){ 
    Y.create(...);
});

- Better collection management

var Y = YUI().use('menu', 'tab').ready(function(Y) { 
    Y.create(...).each(function(w) {
        w.render();
    }.create(...);
});

- Collapsed API for core functionality

Y.on()  // overloaded for DOM events and custom events

Y.get() // overloaded for elements and YUI managed objects 

Y.io()  // async XHR by default, other transports configurable

- More modularization

YUI   - core, array, obj, lang, ua, dump, substitute, later
Dom   - dom, style, screen, domextras, region
Event - event, event-custom, event-available, event-domready, event-dom0, event-key

- Different packages can be delivered with a build and config step

YUI.add("yui", M, "3.0.0", {
    // full backwards compatibility
    use: ["lang", "array", "core", "object", "ua", "dump", "substitute", "later", "compat"]
});

YUI.add("yui", M, "3.0.0", {
    // smaller
    use: ["lang", "array", "core", "object", "ua"]
});

- Custom events in the core

var Y = YUI().on('yui:newmodule', fn);
Y.use('anim');

- Extracting execution context out of the api

var fn = function(e, data) { };

YAHOO.util.Event.addListener(el, 'click', fn, data, context);

var fn = function(e, data1, data2) { }; // depending on how bind should work
var fn = function(data1, data2, e) { };

Y.on('click', Y.bind(fn, context, data1, data2), el);

This way the core signature has only a single optional argument, making it possible to
have the same signature for more types of events.

- Dom events wrapped in custom events

    Y.on('click', fn, el); 
    Y.before('click', fn, el); 

- This approach makes it fairly trivial to choose between dom2 vs dom0 style event

- Return value from subscribe is a handle for unsubscribe

var handle = Y.on('click', fn, el);

handle.detach();
Y.detach(handle);

- Multiple types and targets

var handles = Y.on(['click', 'mousedown'], fn, [id1, id2]);
Y.each(handles, function(h) { h.detach() });

- listeners get an event facade rather than an event

YAHOO.util.Event.addListener(el, 'click', function(e) {
    var target  = YAHOO.util.event.getTarget(e),
        boundEl = this // if context was not adjusted -- otherwise not available
    YAHOO.util.Event.stopEvent(e); // preventDefault, stopPropagation
});

Y.on('click', function(e) {
    var target  = e.target, 
        boundEl = t.originalTarget;
    e.halt();
}, el);

- stopImmediatePropagation

Y.on('click', function(e) {
    e.halt(); // or e.stopImmediatePropagation();
}, el);

Y.on('click', function(e) {
    Y.log('can't prevent this from being executed in 2.x');
}, el);

///////////////////////////////////////////////////////////////////////

Y.log uses the console and dispatches a 'yui:log' event
    set 'debug' option to off to disable all logging
    set useConsole option to turn off the Y.log console logging

Custom events default to the FLAT signature.  This means the first parameter is no longer the event name.

FLAT signature now provides all arguments supplied after the context object

onDOMReady event has the FLAT signature
onDOMReady event is fireOnce

DOM events are wrapped in custom events

getListeners now returns a list of the custom event wrappers for the Dom events

Event.Facade targets are now Y.Node instances if Y.Node is available

Get is integrated, but not through the Y.io interface (Y.Get.script)

When binding listeners by id, Event expects selector syntax

Event/CE.subscribe/addListener return a handle object with a detach() method

Unsubscribe/detach still support the old method of detaching events

Event isn't current handling NodeList collections correctly, so Y.Doc.query() can't currently be used to bind multiple listeners

stopImmediatePropagation

///////////////////////////////////////////////////////////////////////

config option for compat layer

querystring param for debug config

dispatch dom events through CE interface
    can execute listeners, but is a mock event object enough?
    stopProbagation and preventDefault wouldn't work

defaultFn, addTarget

Wrap all YUI in anonymous function to secure config options?

CE before/after

Make

///////////////////////////////////////////////////////////////////////

Untrusted Metro instance do not get:

    io

    get

    node

    _setup -- move to compatability layer?

    Deliver a version with only the stuff the untrusted version uses
    
    Make the initial YUI 'use' set a config

///////////////////////////////////////////////////////////////////////

Handle yui:log recursion. 
    Silent flag needs to make subscriber generated custom events silent
    // Event source needed to protect against recursive calls?

//////////////////////////////////////////////////////////////////////

DOMReady refactored so that the YUI global does not have to be event enabled

Y.use('*') works

io is no longer included in yui.js

dump and substitute are still included in yui.js, but they are not bound by default

the compatibility layer is still included in yui.js, but by default it is not bound

added a config option for 'compat', default off.  This hooks up the compatibility layer
set to true.

The YUI global does not get the core library bound to it unless compat is set to true

added a config option for 'core', default undefined.  This is an array that will
supplant the array of core YUI modules bound in Init.js.

Event Facade: fixed to work with new Node interface.  Do (now in the core): fixed multiple subscriber problem

//////////////////////////////////////////////////////////////////////

Fixed Y.log custom event recursion
    This required the addition of a call stack, which may be expanded to provide additional debugging assistance.

originalTarget borrows the reference from addListener instead of the event property to get around a FireFox bug.

Y.extend does not copy object properties any longer.  It also no longer adds Super, which didn't work beyond the first level of inheritance

Fixed a case where log messages were inadvertently suppressed

EventFacade.button == e.which || e.button

Added logInclude and logExclude config options to filter log sources

//////////////////////////////////////////////////////////////////////

Removed the old custom event signatures

Event.Target.subscribe propagates multiple arguments correctly

Event.Target.fire() can now emit Event.Facade payload rather than fire() arguments.  
    defaultFn - default behavior that executes even if a subscriber stops the event propagation
        preventDefault() - prevents if the event is 'cancelable'
    add/removeTarget - provides bubbling if event 'bubbles'
        stopPropagation()/stopImmediatePropagation()
    details - constains arguments provided to fire()
    target - object fire() was executed on
    originalTarget - used to get the subscriber's host when subscriber changes execution context

//////////////////////////////////////////////////////////////////////

Event.Target hasEvent replaced with getEvent

Event.Custom constructor signature is now type and options --- 
removed context and silent as arguments in the constructor, now these
must be passed into the config.

Added 'defaultFn' custom event property

Added 'emitFacade' config that publish() can use to use the Event.Facade signature.
This is in place until we can configure Event.Target to always produce events
with the Event.Facade signature.

When the facade in place, if the first argument is an object, these properties are
mixed into the event facade.  This provides some transparency to events that are
already being used this way, and makes it so that the consumer can use well known
property names rather than e.details[1]

    var o1 = new Y.Event.Target(),
        o2 = new Y.Event.Target(),
        o3 = new Y.Event.Target();

        o1.publish('o:1', {
            defaultFn: function() {
                Y.log('DEFAULT FN o1');
            },

            emitFacade: true
        });

        o1.addTarget(o2);


        o2.addTarget(o3);

        o1.subscribe('o:1', function(e) {
            Y.log('o1: ' + Y.lang.dump(Y.array(arguments)));

            // e.halt();
        });

        o2.subscribe('o:1', function(e) {
            Y.log('o1 to o2: ' + Y.lang.dump(Y.array(arguments)));
        });

        o3.subscribe('o:1', function(e) {
            Y.log('o1 to o3: ' + Y.lang.dump(Y.array(arguments)));
        });


        o3.subscribe('o:2', function(e) {
            Y.log('o2 to o3: ' + Y.lang.dump(Y.array(arguments)));
        });

        // with facade
        o1.fire('o:1', {

            foo: 1,
            bar: "absorbed from fire arg 0"

        }, 2, 3);

        // without facade
        o1.fire('o:2', 4, 5, 6);


changed Y.clone signature to include a 'safe' option

Y.augment big change

    When augmenting a class, the augmented class executes the supplier
    constructor the first time any method from the supplier is invoked.

    When augmenting an instance, the supplier constructor is executed
    immediately.

    Accepts an optional args argument to apply to the supplier's constructor

    Event.Target now uses this feature to configure the emitFacade attribute
    globally on an event target.

    Y.mix(obj, Event.Target.prototype) won't work now, but you just need to switch
    to Y.augment(obj, Event.Target)

Event.Target.fire no longer creates the event if it hasn't been published

    Avoids creating unneeded objects

    However, an event that has not been published (which also means it has
    not been subscribed to) will not bubble.  This may need to be configurable,
    or changed to allow the bubble.


Custom events are queued to make bubble sequence sane
    
    event1 fired
    subscriber to event1 fires event2
    event1 bubble
    event1 defaultFn
    event2 fired
    event2 bubble
    event2 defaultFn

    Events are only queued if the are allowed to (canQueue) as it changes the order
    of operation otherwise (log statements for instance are not queued because
    it would prevent the correct sequence of messages when operating on bubbling events



cancelable -> preventable
canQueue -> queuable


-------------------------

Removed ChainedError
Custom event errors now invoke Y.fail, which can be configured to throw the error or log
Removed Event.Target.before
Implemented Event.Target.after
Added config for stoppedFn and preventedFn... these are exectuted if a subscriber calles
the corresponding function.  They receive the custom event as a param.  Execution context
is the host object or the custom event.
