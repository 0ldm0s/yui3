
YAHOO.env.ua -> Y.ua

YAHOO.util.Dom.get -> Y.get

YAHOO.util.Connect.asynchRequest -> Y.io
YAHOO.util.Connect.* -> Y.io.*

EventProvider -> Y.Event.Target

new YAHOO.util.CustomEvent()

EventProvider.createEvent -> Event.Target.publish

Y.publish('category:type') // global

Y.augment(Class, Y.Event.Target);
var instance = new Class();
instance.publish('type')

lang.augmentProto -> Y.augment
lang.augmentObject -> Y.mix

createEvent -> publish
fireEvent -> fire

addListener(el, type, fn, data, context) ->

    Y.on(type, fn, el, data, context) // this works now, but

    Y.on(type, fn, el) // this is what we are aiming at

    Y.on('click', Y.bind(this.fn, this, data, data), el);

removeListener(el, type, fn, data, context) ->

    Y.detach(type, fn, el, data, context) // this works now, but
    Y.detach(handle) // this is what we are aiming at

-------------------------------------------------------------------------------------

- Use your intstance to sandbox your app.

var Y = YUI();

- Pass an object for global configuration params (loader config, etc)

var Y = YUI(o);

- targeting windows/frames

var Y = YUI(o);

var frameY = YUI({
    win: frame1
};

- You must specify what you will use.

var Y = YUI().use('anim', 'dragdrop');

- You can ask it to load everything it knows about.

var Y = YUI().use('*');

- When possible, core methods return the reference to the YUI instance to allow chaining.

var Y = YUI().use('anim').use('dragdrop);

- It will be able to pull in loader to get all dependencies.

var Y = YUI().use('editor');

- Dynamic loading means the app logic must wait until the YUI instance is done getting stuff

var Y = YUI().use('editor').ready(init);

- Factory method for object creation

var Y = YUI().use('menu', 'tab').ready(function(Y){ 
    Y.create(...);
});

- Better collection management

var Y = YUI().use('menu', 'tab').ready(function(Y) { 
    Y.create(...).each(function(w) {
        w.render();
    }.create(...);
});

- Collapsed API for core functionality

Y.on()  // overloaded for DOM events and custom events

Y.get() // overloaded for elements and YUI managed objects 

Y.io()  // async XHR by default, other transports configurable

- More modularization

YUI   - core, array, obj, lang, ua, dump, substitute, later
Dom   - dom, style, screen, domextras, region
Event - event, event-custom, event-available, event-domready, event-dom0, event-key

- Different packages can be delivered with a build and config step

YUI.add("yui", M, "3.0.0", {
    // full backwards compatibility
    use: ["lang", "array", "core", "object", "ua", "dump", "substitute", "later", "compat"]
});

YUI.add("yui", M, "3.0.0", {
    // smaller
    use: ["lang", "array", "core", "object", "ua"]
});

- Custom events in the core

var Y = YUI().on('yui:newmodule', fn);
Y.use('anim');

- Extracting execution context out of the api

var fn = function(e, data) { };

YAHOO.util.Event.addListener(el, 'click', fn, data, context);

var fn = function(e, data1, data2) { }; // depending on how bind should work
var fn = function(data1, data2, e) { };

Y.on('click', Y.bind(fn, context, data1, data2), el);

This way the core signature has only a single optional argument, making it possible to
have the same signature for more types of events.

- Dom events wrapped in custom events

    Y.on('click', fn, el); 
    Y.before('click', fn, el); 

- This approach makes it fairly trivial to choose between dom2 vs dom0 style event

- Return value from subscribe is a handle for unsubscribe

var handle = Y.on('click', fn, el);

handle.detach();
Y.detach(handle);

- Multiple types and targets

var handles = Y.on(['click', 'mousedown'], fn, [id1, id2]);
Y.each(handles, function(h) { h.detach() });

- listeners get an event facade rather than an event

YAHOO.util.Event.addListener(el, 'click', function(e) {
    var target  = YAHOO.util.event.getTarget(e),
        boundEl = this // if context was not adjusted -- otherwise not available
    YAHOO.util.Event.stopEvent(e); // preventDefault, stopPropagation
});

Y.on('click', function(e) {
    var target  = e.target, 
        boundEl = t.originalTarget;
    e.halt();
}, el);

- stopImmediatePropagation

Y.on('click', function(e) {
    e.halt(); // or e.stopImmediatePropagation();
}, el);

Y.on('click', function(e) {
    Y.log('can't prevent this from being executed in 2.x');
}, el);

///////////////////////////////////////////////////////////////////////

Y.log uses the console and dispatches a 'yui:log' event
    set 'debug' option to off to disable all logging
    set useConsole option to turn off the Y.log console logging

Custom events default to the FLAT signature.  This means the first parameter is no longer the event name.

FLAT signature now provides all arguments supplied after the context object

onDOMReady event has the FLAT signature
onDOMReady event is fireOnce

DOM events are wrapped in custom events

getListeners now returns a list of the custom event wrappers for the Dom events

Event.Facade targets are now Y.Node instances if Y.Node is available

Get is integrated, but not through the Y.io interface (Y.Get.script)

When binding listeners by id, Event expects selector syntax

Event/CE.subscribe/addListener return a handle object with a detach() method

Unsubscribe/detach still support the old method of detaching events

Event isn't current handling NodeList collections correctly, so Y.Doc.query() can't currently be used to bind multiple listeners

stopImmediatePropagation

///////////////////////////////////////////////////////////////////////

config option for compat layer

querystring param for debug config

dispatch dom events through CE interface
    can execute listeners, but is a mock event object enough?
    stopProbagation and preventDefault wouldn't work

defaultFn, addTarget

Wrap all YUI in anonymous function to secure config options?

CE before/after

Make

///////////////////////////////////////////////////////////////////////

Untrusted Metro instance do not get:

    io

    get

    node

    _setup -- move to compatability layer?

    Deliver a version with only the stuff the untrusted version uses
    
    Make the initial YUI 'use' set a config

///////////////////////////////////////////////////////////////////////

Handle yui:log recursion. 
    Silent flag needs to make subscriber generated custom events silent
    // Event source needed to protect against recursive calls?

//////////////////////////////////////////////////////////////////////

DOMReady refactored so that the YUI global does not have to be event enabled

Y.use('*') works

io is no longer included in yui.js

dump and substitute are still included in yui.js, but they are not bound by default

the compatibility layer is still included in yui.js, but by default it is not bound

added a config option for 'compat', default off.  This hooks up the compatibility layer
set to true.

The YUI global does not get the core library bound to it unless compat is set to true

added a config option for 'core', default undefined.  This is an array that will
supplant the array of core YUI modules bound in Init.js.

