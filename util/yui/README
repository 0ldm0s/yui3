
YAHOO.env.ua -> Y.ua

YAHOO.util.Dom.get -> Y.get

YAHOO.util.Connect.asynchRequest -> Y.io
YAHOO.util.Connect.* -> Y.io.*

EventProvider -> Y.Event.Target

new YAHOO.util.CustomEvent()

EventProvider.createEvent -> Event.Target.publish

Y.publish('category:type') // global

Y.augment(Class, Y.Event.Target);
var instance = new Class();
instance.publish('type')

lang.augmentProto -> Y.augment
lang.augmentObject -> Y.mix

createEvent -> publish
fireEvent -> fire

addListener(el, type, fn, data, context) ->

    Y.on(type, fn, el, data, context) // this works now, but

    Y.on(type, fn, el) // this is what we are aiming at

    Y.on('click', Y.bind(this.fn, this, data, data), el);

removeListener(el, type, fn, data, context) ->

    Y.detach(type, fn, el, data, context) // this works now, but
    Y.detach(handle) // this is what we are aiming at

-------------------------------------------------------------------------------------

- Use your intstance to sandbox your app.

var Y = YUI();

- Pass an object for global configuration params (loader config, etc)

var Y = YUI(o);

- targeting windows/frames

var Y = YUI(o);

var frameY = YUI({
    win: frame1
};

- You must specify what you will use.

var Y = YUI().use('anim', 'dragdrop');

- You can ask it to load everything it knows about.

var Y = YUI().use('*');

- When possible, core methods return the reference to the YUI instance to allow chaining.

var Y = YUI().use('anim').use('dragdrop);

- It will be able to pull in loader to get all dependencies.

var Y = YUI().use('editor');

- Dynamic loading means the app logic must wait until the YUI instance is done getting stuff

var Y = YUI().use('editor').ready(init);

- Factory method for object creation

var Y = YUI().use('menu', 'tab').ready(function(Y){ 
    Y.create(...);
});

- Better collection management

var Y = YUI().use('menu', 'tab').ready(function(Y) { 
    Y.create(...).each(function(w) {
        w.render();
    }.create(...);
});

- Collapsed API for core functionality

Y.on()  // overloaded for DOM events and custom events

Y.get() // overloaded for elements and YUI managed objects 

Y.io()  // async XHR by default, other transports configurable

- More modularization

YUI   - core, array, obj, lang, ua, dump, substitute, later
Dom   - dom, style, screen, domextras, region
Event - event, event-custom, event-available, event-domready, event-dom0, event-key

- Different packages can be delivered with a build and config step

YUI.add("yui", M, "3.0.0", {
    // full backwards compatibility
    use: ["lang", "array", "core", "object", "ua", "dump", "substitute", "later", "compat"]
});

YUI.add("yui", M, "3.0.0", {
    // smaller
    use: ["lang", "array", "core", "object", "ua"]
});

- Custom events in the core

var Y = YUI().on('yui:newmodule', fn);
Y.use('anim');

- Extracting execution context out of the api

var fn = function(e, data) { };

YAHOO.util.Event.addListener(el, 'click', fn, data, context);

var fn = function(e, data1, data2) { }; // depending on how bind should work
var fn = function(data1, data2, e) { };

Y.on('click', Y.bind(fn, context, data1, data2), el);

This way the core signature has only a single optional argument, making it possible to
have the same signature for more types of events.

- Dom events wrapped in custom events

    Y.on('click', fn, el); 
    Y.before('click', fn, el); 

- This approach makes it fairly trivial to choose between dom2 vs dom0 style event

- Return value from subscribe is a handle for unsubscribe

var handle = Y.on('click', fn, el);

handle.detach();
Y.detach(handle);

- Multiple types and targets

var handles = Y.on(['click', 'mousedown'], fn, [id1, id2]);
Y.each(handles, function(h) { h.detach() });

- listeners get an event facade rather than an event

YAHOO.util.Event.addListener(el, 'click', function(e) {
    var target  = YAHOO.util.event.getTarget(e),
        boundEl = this // if context was not adjusted -- otherwise not available
    YAHOO.util.Event.stopEvent(e); // preventDefault, stopPropagation
});

Y.on('click', function(e) {
    var target  = e.target, 
        boundEl = t.originalTarget;
    e.halt();
}, el);

- stopImmediatePropagation

Y.on('click', function(e) {
    e.halt(); // or e.stopImmediatePropagation();
}, el);

Y.on('click', function(e) {
    Y.log('can't prevent this from being executed in 2.x');
}, el);


Custom events default to the LIST signature.  This means the first
parameter is no longer the event name

onDOMReady event is has the LIST signature
onDOMReady event is fireOnce (verify this works)

DOM events are wrapped in custom events


