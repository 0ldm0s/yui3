<?php 
$title="The Base Utility";
$section="base";
$component="Base Utility";
$highlightSyntax = true;
$releasenotes = true;
include "../inc/header.inc";
?>
<div id="yui-main">
    <div class="yui-b">
        <div class="yui-ge">
            <div class="yui-u first" id="main">
            <!-- main column -->

                <h2><?php echo $component;?></h2>

                <div id="promo" class="component">
                    <p>Base is designed to be a low level class from which other attribute and event target based classes in the
                    YUI library can be derived. It provides a standard template for creating attribute based objects across the 
                    library and provides a consistent <code>init()</code> and <code>destroy()</code> sequence, by chaining initialization (<code>initializer</code>) 
                    and destruction (<code>destructor</code>) methods for the class hierarcy.</p>
                    <div class="yui-g">
                        <div class="yui-u first">
                            <div id="jumps">
                                <h4>On This Page</h4>
                                <ul>
                                    <li><a href="#start">Getting Started</a></li>
                                    <li><a href="#using">Using the <?php echo $component;?></a>
                                        <ul class="topspace">
                                            <li><a href="#extendbase">Extending Base</a></li>
                                            <li><a href="#staticprops">Static Properties</a>
                                                <ul>
                                                    <li><a href="#nameprop">The NAME Property</a></li>
                                                    <li><a href="#attrsprop">The ATTRS Property</a></li>
                                                </ul>
                                            </li>
                                            <li><a href="#initdestroy">Initialization and Destruction</a></li>
                                            <li><a href="#buildcreate">Build and Create</a></li>
                                        </ul></li>
                                    <li><a href="#support">Support &amp; Community</a></li>
                                    <li><a href="#filingbugs">Bug Reports &amp; Feature Requests</a></li>
                                </ul>
                            </div>
                        </div>
                        <div class="yui-u">
                            <?php
                            include('../inc/quicklinks.inc');
                            ?>
                        </div>
                    </div>
                    <div class="clear"></div>
                </div><!-- /promo -->

                <h3 id="start">Getting Started</h3>

               <h4 id="dependencies">Include Dependencies</h4>

               <p>The easiest way to include the source files for Base and it dependencies, is to add the YUI seed file to your page, using the following script tag, and allow the YUI instance to download any additional files which maybe required:</p> 

                <textarea name="code" class="HTML" cols="60" rows="1">
                &lt;!-- YUI Seed --&gt;
                &lt;script src=&quot;http://yui.yahooapis.com/<?php echo($yuiCurrentVersion);?>/build/yui/yui-min.js&quot; type="text/javascript"&gt;&lt;/script&gt;
                </textarea>

                <p>The YUI instance will automatically pull down Base's source files, along with any dependent files missing from the page, when the <code>base</code> module is used in your code. 
                This helps you avoid having to manually manage the list of files which need to be included on your page to support multiple components, while also optimizing your initial page weight by loading files only when they are required.</p>

                <p>If you do want to include file dependencies manually on your page, the YUI Configurator (discussed below), can be used to determine the list of files you need to include in order to use Base.</p>

                <?php
                    include "../inc/include-notice.inc";
                ?>

                <h4 id="yui">The YUI Instance</h4>

                <p>Once you have the YUI seed file on your page (<code>yui-min.js</code>), you can create a new YUI instance for your application to use, and populate it 
                with the modules you need. In the case of Base, you only need to request the <code>base</code> module using YUI's <code>use</code> method, 
                passing in a callback function which will be invoked when all the file dependencies have been downloaded:</p>

                <textarea name="code" class="JScript" cols="60" rows="1">
                    YUI().use("base", function(Y) {

                        // Y.Base available, and ready for use.

                    });
                </textarea>

                <p>The call to <code>use</code> will populate the local YUI instance (<code>Y</code>) passed back to your callback function, with the 
                classes which make up the <code>base</code> module (e.g. <code>Y.Base</code>) and any other modules which <code>base</code> requires.
                Any required file dependencies not already on the page will be pulled down automatically by the YUI instance if you're using the YUI seed 
                file.</p>

                <p>For more information on creating instances of YUI and the <a href="../yui/index.html#use"><code>use</code> method</a>, see the <a href="../yui/index.html">YUI Global</a> object documentation.</p>

                <h3 id="using">Using the <?php echo $component;?></h3>

                <p>This section describes how to use the <?php echo $component;?> in further detail.  It contains these subsections:</p>
                <ul class="topspace">
                    <li><a href="#extendbase">Extending Base</a></li>
                    <li><a href="#staticprops">Static Properties</a>
                        <ul>
                            <li><a href="#nameprop">The NAME Property</a></li>
                            <li><a href="#attrsprop">The ATTRS Property</a></li>
                        </ul>
                    </li>
                    <li><a href="#initdestroy">Initialization and Destruction</a></li>
                    <li><a href="#buildcreate">Build and Create</a></li>
                </ul>

            <h4 id="extendbase">Extending Base</h4>

            <p>Although Base can be instantiated, it's really designed to be a root class, which you extend when creating your 
            own <code>Attribute</code> and <code>Event.Target</code> based classes as shown below:</p>

            <textarea name="code" class="JScript" cols="60" rows="1">
                YUI().use("base", function(Y) {

                    function MyClass(config) {

                        // Invoke Base constructor, passing through arguments
                        MyClass.superclass.constructor.apply(this, arguments);
                    }

                    Y.extend(MyClass, Y.Base, {
                        // Prototype methods for your new class
                    });
                });
            </textarea>

            <p>Base itself augments <code>Attribute</code>, which in turn augments <code>Event.Target</code>, making Base an Attribute provider and 
            an Event Target.</p>

            <p>Base's contructor expects a configuration object literal, which is used to setup initial values for attributes during construction (discussed below).</p>

            <h4 id="staticprops">Static Properties</h4>

            <p>Base looks for a couple of "static" properties, which it requires you to add to your class constructor - <code>NAME</code> and <code>ATTRS</code>, which it uses when 
            setting up events and attributes for the class:</p>

            <textarea name="code" class="JScript" cols="60" rows="1">
            function MyClass(config) {
                MyClass.superclass.constructor.apply(this, arguments);
            }

            // Used to identify instances of this class
            // For example, to prefix event names

            MyClass.NAME = "myclass";

            // "Associative Array", used to define the set of attributes 
            // added by this class. The name of the attribute is the key,
            // and the object literal value acts as the configuration 
            // object passed used to configure the attribute

            MyClass.ATTRS = {
                A : {
                    // Attribute "A" configuration
                },
            
                B : {
                    // Attribute "B" configuration
                }
            }

            Y.extend(MyClass, Y.Base, {
                // Prototype methods for your new class
            });
            </textarea>

            <h5 id="nameprop">NAME</h5>

            <p>The <code>NAME</code> property is a string which is used to identify the class.</p>

            <p>One core area where it is currently used is to prefix all events which are published by instances of your class.
            For example, any events published by the class <code>MyClass</code> in the above code snippet, will have the "myclass" prefix.</p>

            <p>Event prefixes allow events with the same name fired from instances of different classes to be uniquely identified, <em>(e.g. Menu "click" vs. Editor "click" events when bubbled up to a common target object)</em>
            without publishers or subscribers of the events needing to manually namespace them whenever they call Event.Target's <code>subscribe, fire ,publish</code> methods or Attribute's <code>on</code> method from the instance. e.g:</p>

            <textarea name="code" class="JScript" cols="60" rows="1">
            // NAME is used to prefix the provided event type, if not already prefixed,
            // when publishing, firing and subscribing to events.
            
            MyClass.prototype.doSomething = function() {
                // Actually fires the event type "myclass:enabled"
                this.fire("enabled");
            }
            
            ...
            
            var o = new MyClass(cfg);
            
            o.on("enabled", function() {
                // Actually listening for "myclass:enabled".
            });
            
            o.on("myclass:enabled", function() {
                // Also listening for "myclass:enabled"
            });
            </textarea>

            <p>It is also used in the default <code>toString</code> implementation for Base.</p>

            <h5 id="attrsprop">ATTRS</h5>

            <p>The <code>ATTRS</code> property is an associative array (object literal) which is used to define the default set of 
            attributes the class adds to the instance. The instance will contain attributes defined by each class in the class
            hierarchy from which it is created, with each class adding the set of attributes and supporting code which it 
            requires.</p>

            <p>For example, this is the (partial) set of attributes which the <a href="../api/Drag.html">Drag</a> class defines:</p>

            <textarea name="code" class="JScript" cols="60" rows="1">
            Drag.ATTRS = {
            
                node: {
                    set: function(node) {
                        var n = Y.Node.get(node);
                        if (!n) {
                            Y.fail('DD.Drag: Invalid Node Given: ' + node);
                        }
                        return n;
                    }
                },
            
                dragNode: {
                    set: function(node) {
                        var n = Y.Node.get(node);
                        if (!n) {
                            Y.fail('DD.Drag: Invalid dragNode Given: ' + node);
                        }
                        return n;
                    }
                },
            
                offsetNode: {
                    value: true
                },
            
                clickPixelThresh: {
                    value: DDM.get('clickPixelThresh')
                },
            
                ...
            
            }; // End of Drag.ATTRS associative array (object literal)
            </textarea>

            <p>Each property in the object literal (e.g. <code>"dragNode"</code>), defines the name of the attribute to be added, and 
            the corresponding value defines the attribute's configuration. See <a href="../attribute/index.html#configuration">Attribute's discussion of configuration properties</a>
            for more details about the structure of configuration object for each attribute.</p>

            <p>When instantiating an instance of a class derived from Base, Base's <code>init()</code> method , will initialize 
            the set of attributes defined by the <code>ATTRS</code> property for each class in the class heirarchy. This helps avoid
            replicating attribute initialization code in the constructor/initializer of each class and defines a specific order in which
            attributes are initialized - starting from the Base class first, and ending with the specific sub-class being instantiated.</p>

            <h4 id="initdestroy">Initialization and Destruction</h4>

            <p>Base implements final versions of it's <code>init</code> and <code>destroy</code> methods used to establish the init and destroy lifecycle phases.
            Classes extending Base can perform operations during initialization or destruction, by defining prototype level <code>initializer</code> and <code>destructor</code> methods respectively:</p>

            <textarea name="code" class="JScript" cols="60" rows="1">
            Y.extend(MyClass, Y.Base, {
            
                // Prototype methods for your new class
            
                // Tasks MyClass needs to perform during
                // the init() lifecycle phase
                initializer : function(cfg) {
                    this._wrapper = Y.Node.create('<div class="yui-wrapper"></div>');
                },
            
                // Tasks MyClass needs to perform during 
                // the destroy() lifecycle phase
                destructor : function() {
                    Y.Event.purgeElement(this._wrapper);
                    this._wrapper.get("parentNode").removeChild(this._wrapper);
                    this._wrapper = null;
                }
            
            });
            </textarea>

            <p>Base's <code>init</code> and <code>destroy</code> methods take care of invoking <code>intializer</code> and <code>destructor</code> methods for each class in the hierarchy.
            The implementations for each class do not need to call superclass versions of the method. This way Base can ensure that intialization and destruction occur 
            in a fixed order, following the class hierarchy.</p>

            <dl>
                <dt><code>initializer()</code></dt>
                <dd>
                    Base's <code>init</code> method will invoke the <code>initializer</code> method for each class in the hierarchy - starting from the Base class first and ending with the sub-class being instantiated,
                    when it is called as part of Base's constructor. The <code>initializer</code> method for each class is invoked after it's attributes have been initialized 
                    (as discussed above) and will receive the configuration object literal passed to the <code>init</code> method.
                </dd>
                <dt><code>destructor()</code></dt>
                <dd>
                    Base's <code>destroy</code> method when called, will invoke the <code>destructor</code> method for each class in the hierarchy - starting from the sub-class instantiated to create the instance, and ending with the Base class (the opposite of initialization).
                </dd>
            </dl>

            <p>If your class does not require any code to be executed during <code>init</code> or <code>destroy</code>, you do not need to define the corresponding <code>initializer</code> or <code>destructor</code> method on it's prototype.</p>

            <h4 id="buildcreate">Build and Create</h4>

            <p>In addition to the class hierarchy based support discussed above, the <code>Base</code> class also provides two static methods <code>build</code> and <code>create</code>, used to create custom
            classes or instances of classes derived from Base.</p>

            <p><strong>NOTE:</strong> <code>build</code> and <code>create</code> are not currently being used by code in the 3.0.0 PR1 release and may be modified in future preview releases as requirements are refined.</p>

            <h5>Build</h5>

            <p>The <code>build</code> method can be used to dynamically create new classes, which are derived from an existing main class and mix in additional "extension" classes to add methods, attributes, events and properties to the main class.
            By default, <code>build</code> leaves the original main and mixed in classes untouched, so that the main class can still be used without the additional features mixed in. However <code>build</code> can be invoked with a configuration 
            option so that it modifies the main class if required.</p>

            <textarea name="code" class="JScript" cols="60" rows="1">

            /* Main Class */
            function Panel(cfg) {
                Panel.superclass.constructor.apply(this, arguments);
            }

            Panel.ATTRS = {
                // Panel attributes
                close : { ... },
                minimize : { ... },
                shadow : { ... },
                ...
            };

            Y.extend(Panel, Y.Base, {
                // Panel methods
                show : function() { ... },
                hide : function() { ... },
                minimize : function() { ... }
            };
            
            /* Additional Resizable Feature */
            function Resizable() {
                this._initResizable();
            }
            
            Resizable.ATTRS = {
                handles : { ... },
                constrain : { ... }
            };
            
            Resizable.prototype = {
                _initResizable : function() { ... } 
                lock : function() { ... }
            };
            
            /* Additional Modality Feature */
            function Modal() {
                this._initModality();
            }
            
            Modal.ATTRS = {
                modal : { ... },
                region : { ... }
            };
            
            Modal.prototype = {
                _initModality : function() { ... },
                showMask() : function() { ... },
                hideMask() : function() { ... }
            };

            // Create a new class WindowPanel, which extends Panel, and 
            // combines methods/attributes from Resizable and Modal

            var WindowPanel = Y.Base.build(Panel, [Resizable, Modal]);

            var wp = new WindowPanel({
                shadow: true, 
                modal: true, 
                handles:["e", "s", "se"]
            });

            wp.show();
            wp.lock();
            </textarea>

            <p>Under the hood, <code>build</code>:</p>
            <ul>
                <li>Creates a new 'built' class by extending the main class passed in as the first argument.</li>
                <li>Augments the list of feature classes (the 2nd argument) to the built class, so that it now has their prototype methods.</li>
                <li>Aggregates any known static properties (by default <code>ATTRS</code> is aggregated) on the built class.
                The caller can provide other properties to aggregate also, using the 3rd configuration argument to build.</li>
            </ul>

            <p>The new class constructor created by <code>build</code> will invoke the constructors for the main and feature classes when the new class is instantiated.</p>
            
            <p>See Base's <a href="../api/Base.html#method_build">build method API documentation</a> for more details about the build method.</p>

            <h5>Create</h5>

            <p><code>create</code> works in the same way as build, but allows the caller to create instances of the dynamically created class, with the ability to pass in arguments
            to the constructor:</p>

            <textarea name="code" class="JScript" cols="60" rows="1">
            var wp = Y.Base.create(Panel, [Resizable, Modal], {
                shadow: true, 
                modal: true, 
                handles:["e", "s", "se"]
            });
            </textarea>

            <?php # include "../inc/mobileSection.inc";?>
            <?php include "../inc/support.inc"; ?>

        </div>
        <div class="yui-u sidebar">
            <div id="delicious" class="mod box4">
               <div class="hd delicious">
                <h4>YUI <?php echo $component;?> on del.icio.us:</h4>
               </div>
               <div class="bd delicious">
                   <?php
                    $thisURI="http://developer.yahoo.com/yui/3/$section/";
                    require_once('../inc/badge.inc');
                   ?>
                   <?php require('../inc/badge-html.inc'); ?>
               </div>
            </div>
        </div>
      </div>
</div>
</div>
<?php include "../inc/side.inc" ?>
<?php include "../inc/footer.inc" ?>
