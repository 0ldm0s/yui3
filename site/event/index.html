<?php 
$title="The Event Utility";
$section="event";
$component=" Event Utility";
$highlightSyntax = true;
$releasenotes = true;
include "../inc/header.inc";
?>
<div id="yui-main">
	<div class="yui-b">
		<div class="yui-ge">
			<div class="yui-u first" id="main">
			<!-- main column -->
			
				<h2><?php echo $component;?></h2>
			
				<div id="promo" class="component">
					 <p>YUI's Event Utility facilitates the creation of event-driven applications in the browser by giving you a simplified interface for responding DOM events. The Event Utility package also includes the Custom Event object; Custom Events allow you to publish the interesting moments or events in your own code so that other components on the page can subscribe to those events and respond to them.</p>
                    
                    <p>The Event Utility package provides the following features: </p>

    <ul>
      <li>DOM event handling</li>
      <li>Automatic deferral of handler attachment for elements that are not yet available</li>
      <li>Automatic scope correction, optional scope assignment</li>
      <li>An event facade that normalizes browser differences</li>
      <li>Automatic DOM event listener cleanup</li>
      <li>Pageload timing events (<code>onAvailable</code> and <code>onContentReady</code> at the element level and <code>event:ready</code> at the DOM level)
      <li>Custom events that are bubbleable, cancelable, and have intrinsic AOP qualities</li>
   </ul>
   
   
					<div class="yui-g">
						<div class="yui-u first">
							<div id="jumps">
								<h4>On This Page</h4>
								<ul>
									<li><a href="#start">Getting Started</a></li>
									<li><a href="#using">DOM Events</a></li>
									<li><a href="#removeevent">Removing Events</a></li>
									<li><a href="#onavailable">Using the <code>onAvailable</code> and <code>onContentReady</code> Methods</a></li>
									<li><a href="#ondomready">Using the <code>event:ready</code> Event (Formerly <code>onDOMReady</code>)</a></li>
									<li><a href="#customevent">Using the CustomEvent Object</a></li>
									<li><a href="#support">Support &amp; Community</a></li>
									<li><a href="#filingbugs">Bug Reports &amp; Feature Requests</a></li>
								</ul>
							</div>
						</div>
						<div class="yui-u">
							<?php
							include('../inc/quicklinks.inc');
							?>
						</div>
					</div>				
					<div class="clear"></div>
				</div><!-- /promo -->
				
				<h3 id="start">Getting Started</h3>
				
				<h4 id="dependencies">Include Dependencies</h4>
				
				<p>To use the <?php echo $component;?>, include the following source files in your web page with the script tag:</p>
				<textarea name="code" class="HTML" cols="60" rows="1">
<!-- -->
				</textarea>

				<?php
				include "../inc/include-notice.inc";
				?>
               
				
              <h3 id="domEvents">DOM Events</h3>
                <p>To attach an event handler to the DOM, simply define your event handler and pass the event handler to the Event Utility along with a reference to the event for which you want to listen and the element to which you want attach the handler: </p>
<pre><textarea name="code" class="JScript" cols="60" rows="1">
//the function we'll use to handle the event:
function handleClick(e) {
	//Pass the event facade to the logger or console for
    //inspection:
    Y.log(e);
}

//assuming we have an element on the page with an ID
//attribute "foo":
var Y = YUI();
Y.on("click", handleClick, "#foo");</textarea></pre>

    <p>These lines of code:</p>
    <ul>
        <li>Create a YUI instance &mdash; Event Utility is always available, so <code>Y.yui().use("event")</code> is not necessary.</li>
        <li>Define a callback function, <code>handleClick(e)</code>, to handle  the specified
          event.</li>
        <li>Call the <code>on</code> method on the YUI instance (<code>Y</code>) to 
          bind an event to the DOM element. The <code>on</code> method requires three
          arguments: the event to bind (<code>"click"</code>, as a string), the callback function  (<code>handleClick</code>), and the element the event is bound to (<code>"#foo"</code>, assuming an element whose ID attribute is <code>foo</code>).</li>
  </ul>
    <p>Because we are identifying the element by its HTML ID (<code>"#foo"</code> as a string) rather than by passing in a Node instance or a direct HTMLElement reference, it is possible to refer to an element that does not yet exist on the page. The Event Utility attempts to find the DOM element by its <code>id</code> value; should it fail to find the element immediately, it continues to seek the element for up to 15 seconds after the page has loaded. This "automatic deferral" enables you, in some cases, to write your event attachment code directly into your script rather than separating it out in a function that runs only after the page has loaded.</p>
   
    <p>To attach an event handler to multiple elements, use CSS selector syntax (as above) that selects multiple elements, pass in multiple selector strings as an array, pass in an array of Node instances, or pass in an array of direct element references:</p>

<pre><textarea name="code" class="JScript" cols="60" rows="1">var Y = YUI();

//elements can be targeted using selector syntax:
Y.on("click", handleClick, "#foo p"); //targets all p elements that are descendants
									  //of #foo
                                      
//elements can be targeted by Node references:
var foo = Y.Node.get("#foo");
Y.on("click", handleClick, foo);
foo.on("click", handleClick); //same as above

//elements can be passed in as direct references:
var foo = document.getElementById("foo");
Y.on("click", handleClick, foo);

//In all cases, you can pass in an array instead of a
//single item:
Y.on("click", handleClick, ["#foo p", "#bar"])</textarea></pre>
<h4 id="on">Using <code>on</code>: Controlling Context and Arguments</h4>

<p>When you call <code>Y.on</code>, you have the following arguments to work with:</p>
<ol>
  <li><strong>Event name:</strong> This is the string reference to the DOM event to which you want to respond (e.g., &quot;<code>click</code>&quot; or &quot;<code>mouseover</code>&quot;). Developers often wonder where they can find a comprehensive list of DOM events that shows in which browsers each event is supported. As far as we know, no perfect list exists.  Danny Goodman's <em><a href="http://www.oreillynet.com/catalog/9780596527402/">DHTML: The Definitive Reference</a></em> may have the most comprehensive information of this kind; PPK's <a href="http://www.quirksmode.org/js/events_compinfo.html">Event Compatibility Table</a> on quirksmode may have the best compatibility assessment online.  The Event Utility does not place any constraints on the events for which you attach handlers; it will attempt to attach listeners for any event name you provide.  It's your responsibility to make sure that the event you're using is one that is supported in the browsers for which you're developing.</li>
  <li><strong>Handler: </strong>A reference to the function that should be called when the specified event takes place.</li>
  <li><strong>Element(s):</strong> As noted above, this can be one or more elements referenced using selector syntax, Node instances, or direct element references.</li>
  <li><strong>Context object:</strong> A reference to the object that will provide the context for the event handler &mdash; the object to which <code>this</code> will refer when the handler executes. If this is omitted, the context object will be a Node instance based on the target element.</li>
  <li><strong>Argument 1 ... <em>n</em>:</strong> The fifth thru <em>n</em>th arguments passed to on will be passed to the event handler.</li>
  </ol>
  
<p>The following code shows these arguments in use.  HTML:</p>

<textarea name="code" class="HTML" cols="60" rows="1"><div id="list">
	<ul>
		<li id="one" class="odd">Item one</li>
        <li id="two" class="even">Item two</li>
	    <li id="three" class="odd">Item three</li>
	    <li id="four" class="even">Item four</li>
	</ul>
</div></textarea>

<p>Script:</p>

<textarea name="code" class="JScript" cols="60" rows="1">//Create YUI instance:
var Y = new YUI().use("dump");

//create arbitrary context object:
var contextObj = {
	name: "context"
};

//function to handle click events and report information about them:
function handleClick(e, arg1, arg2) {
	Y.log("Context object:" + Y.dump(this));
	Y.log("Event facade object:" + Y.dump(e));
	Y.log(arguments);
}

//subscribe odd numbered list items to the click event
Y.on("click", handleClick, "#list .odd", contextObj, "argumentOne", "argumentTwo");</textarea>

<p>When you run this code and click on "Item one" or "Item three", the following information will be sent to <code>Y.log</code>:</p>

<textarea name="code" class="JScript" cols="60" rows="1">Context object: {name => context}
Event facade object: {
	altKey => false, 
    cancelBubble => false, 
    ctrlKey => false, 
    //and remaining event facade properties
    ...}</textarea>
    
<p>The final object logged, the <code>arguments</code> object, will contain three items: <code>e</code> (the event facade), "argumentOne" (string), and "argumentTwo" (string).</p>


<h4>Legacy Methods: <code>Event.addListener</code> and <code>Event.on</code></h4>

<p>The Event Utility contains two legacy methods for attaching event listeners; these are located in the <code>Event</code> package and follow the syntax of the Event Utility from previous versions of YUI.  If you are writing code using YUI 3.x, you should avoid using these methods and instead use the syntax described above.</p>

<h3 id="removeevent">Removing Events</h3>

<p>There are two ways to remove an event listener:</p>
<ol>
  <li><strong>Call detach on the event's handle:</strong> The return value of on is an event handle object; that object contains a detach method that can be used to remove the event.</li>
  <li><strong>Call the YUI detach method, passing in event type, handler, and element:</strong> detach is available as a method on your YUI instance and can be used when you don't have access to the event handle.</li>
</ol>
<p>Sample code for each of these methods:</p>
<textarea name="code" class="JScript" cols="60" rows="1">//Get a YUI instance:
var Y = YUI();

//an event handler:
function handleClick(e) {
	Y.log(e);
}

//attach an event handler to element foo:
var fooHandle = Y.on("click", handleClick, "#foo");

//detach the handler using the handle:
fooHandle.detach();

//detach the handler via detach:
Y.detach("click", handleClick, "#foo");

//or pass the event handle to detach:
Y.detach(fooHandle);</textarea>

<p><code>Event.purgeElement</code> lets you remove all listeners that were registered via <code>on</code> from an element. Optionally, a specific type of listener can be specified. In addition, The element's children can also be purged.
</p>
<textarea name="code" class="JScript" cols="60" rows="1">//get a YUI instance:
var Y = YUI();

// purge all listeners:
Y.Event.purgeElement("#foo");
// all listeners and recurse children:
Y.Event.purgeElement("#foo", true);
// only click listeners, and don't recurse:
Y.Event.purgeElement("#foo", false, "click");</textarea>

<h3 id="onavailable">Using the <code>onAvailable</code> and <code>onContentReady</code> Methods</h3>
<p><code>onAvailable</code> lets you define a function that will execute as soon as an element
  is detected in the DOM. The intent is to reduce the occurrence of timing issues
  when rendering script and html inline. It is not meant to be used to define
  handlers for elements that <em>may</em> eventually be in the document; it is meant to
  be used to detect elements you are in the process of loading.
</p>
<p>
    The argument signature for <code>onAvailable</code> is illustrated here:</p>
    
  
<pre><textarea name="code" class="JScript" cols="60" rows="1">
 &lt;script type="text/javascript"&gt;
 
 var Y = YUI();

 function TestObj(id) {
   Y.Event.onAvailable(id, this.handleOnAvailable, this); 
 }

 TestObj.prototype.handleOnAvailable = function(me) {
   Y.log(this.id + " is available");
 }

 var obj = new TestObj("myelementid");
 &lt;/script&gt;

 &lt;div id="myelementid"&gt;my element&lt;/div&gt;

</textarea></pre>

<p>The <code>onContentReady</code> method shares an identical syntax with <code>onAvailable</code>.  The material difference between the two methods is that <code>onContentReady</code> waits until both the target element and its <code>nextSibling</code> in the DOM respond to <code>getElementById</code>.  This guarantees that the target element's contents will have loaded fully (excepting any dynamic content you might add later via script).  If <code>onContentReady</code> never detects a <code>nextSibling</code>, it fires with the <code>window.load</code> event.</p>

<h3 id="ondomready">Using the <code>event:ready</code> Event (Formerly <code>onDOMReady</code>)</h3>
<p>The <code>event:ready</code> custom event lets you define a function that will execute as soon as the DOM is in a usable state.  The DOM is is not deemed "usable" until it is structurally complete; a number of bugs, primarily in IE, can lead to the browser crashing or failing to load the page successfully if scripts attempt to insert information into the DOM prior to the DOM being in a complete state.</p>

<p>DOM readiness is achieved before images have finished loading, however, so <code>event:ready</code> is often an excellent alternative to using the <code>window</code> object's <code>load</code> event.</p>

<textarea name="code" class="JScript" cols="60" rows="1">
var Y = YUI();

 function init() {
    Y.Node.get("#hidden_element").set("visibility", "");
 }
 Y.on("event:ready", init);

 // As with all custom events, you can pass
 // a context object and arguments that will be
 // passed to your handlers:
 // Y.on("event:ready", init, contexObject, argumentOne, argumentTwo, argumentN);
</textarea>


<h3 id="customevent">Using the CustomEvent Object </h3>
<p>The CustomEvent object enables you to define and use events beyond those available in the DOM &mdash; events that are specific to and of interest in your own application. Custom Events are designed to work much like DOM events.  They can bubble, pass event facades, have their propagation and default behaviors suppressed, etc.  This section describes several common uses of YUI Custom Events and provides some sample code.  It contains these sections: </p>
<ul>
<li> <a href="#customdefine">Defining a Custom Event </a></li>
<li> <a href="#customsubscribe">Subscribing (Listening) to a Custom Event </a></li>
<li><a href="#customfire">Firing the Event </a></li>
</ul>

<h4 id="customdefine">Defining a Custom Event</h4>
<p>The most common way to create a Custom Event is to <code>augment</code> an object with <code>Event.Target</code>, making it able to host Custom Events and be a target Custom Events that are bubbling from other hosts.: </p>
<textarea name="code" class="JScript" cols="60" rows="1">
//Create a YUI instance:
var Y = YUI();

//Define a constructor:
function CustomObject() {
	//create a custom event:
    this.publish("CustomObject:testEvent");
}
//augment the CustomObject with Event.Target:
Y.augment(Publisher, Y.Event.Target);
</textarea>
<p>
The <code>publish</code> constructor creates a new Custom Event; it takes one required parameter and one optional parameters:
</p>
  
<ul>
<li><strong>type</strong> &mdash; The type of event. This string is returned to listeners
  that receive this event so that they know what event occurred.</li> 
 <li><strong>options</strong> &mdash; The specific configuration options you want to define for this Custom Event.  Most properties of the Custom Event class can be set at this time.</li>
 </ul>
<p>


<h3 id="customsubscribe">Subscribing (Listening) to a Custom Event</h3>
<p>To subscribe to a custom event, use its <code>subscribe</code> method.  Following the code above, you would subscribe to the <code>CustomObject:testEvent</code> as follows:</p>
<pre><textarea name="code" class="JScript" cols="60" rows="1">
var customObject = new CustomObject();
customObject.subscribe("CustomObject:testEvent", function() {
	//event handler code
});
</textarea></pre>

<h4 id="customfire">Firing the Event</h4>
<p>To trigger or <code>fire</code> a custom event, simpy call its <code>fire</code> method:</p>

<pre><textarea name="code" class="JScript" cols="60" rows="1">
customObject.fire("CustomObject:testEvent");
</textarea></pre>

<?php include "../inc/mobileSection.inc";?>

<p>The Event Utility works in any browser that has DOM2 event support.
However, the user interaction model of mobile browsers can make certain browser
events behave in a different manner than expected, or not at all.</p>

<p>The iPhone's touch interface supports gestures that prevent
certain mouse events from working correctly.  For instance, the 'mousedown'
event does not fire when the user initially touches the screen over an element.
It only fires once the user's finger is removed (the mousedown, mouseup, and
click events all fire at this moment).  This makes is difficult or impossible
to provide certain DHTML interactions that rely on these events, drag and drop
being the most obvious.</p> 

<p>Since the iPhone has a touch interface, there is
no mouse cursor.  This means that there are no hover states for elements, and
no mouseover events.</p>

<?php 
include "../inc/support.inc";
?>

		</div>
<div class="yui-u sidebar">

	<?php 
	include "../inc/cheatsheet.inc";
	?>
			
			<div id="examples">
<?php 
	include("../inc/examplesNav/".$section.".inc");
?>
		   </div>
		   		   
			<div id="delicious" class="mod box4">
				<div class="hd delicious">
					<h4>YUI <?php echo $component;?> on del.icio.us:</h4>
				</div>
				<div class="bd delicious">
            		<?php
                   	$thisURI="http://developer.yahoo.com/yui/3/$section/";
                   	require_once('../inc/badge.inc');
					?>
         			<?php require('../inc/badge-html.inc'); ?>
         		</div>
        	</div>

		 </div>
      </div>

</div>
</div>

<?php include "../inc/side.inc" ?>
<?php include "../inc/footer.inc" ?>




