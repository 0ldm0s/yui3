<?php 
$title="The Event Utility";
$section="event";
$component="Event Utility";
$highlightSyntax = true;
$releasenotes = true;
$componentShort="event";
$requiredModules=Array("node");
include "../inc/header.inc";
?>
<div id="yui-main">
	<div class="yui-b">
		<div class="yui-ge">
			<div class="yui-u first" id="main">
			<!-- main column -->
			
				<h2><?php echo $component;?></h2>
			
				<div id="promo" class="component">
                     <p>YUI's Event Utility facilitates the creation of
                     event-driven applications in the browser by giving you a
                     simplified interface for responding to DOM events. The Event
                     Utility package also includes the Custom Event object;
                     Custom Events allow you to publish the interesting moments
                     or events in your own code so that other components on the
                     page can subscribe to those events and respond to
                     them.</p>
                    
                    <p>The Event Utility package provides the following
                    features: </p>

    <ul>
      <li>DOM event handling</li>
      <li>Automatic deferral of handler attachment for elements that are not yet available</li>
      <li>Automatic scope correction, optional scope assignment</li>
      <li>An event facade that normalizes browser differences</li>
      <li>Automatic DOM event listener cleanup</li>
      <li>Simulation of events in all A-grade browsers</li>
      <li>Pageload timing events (<code>available</code> and <code>contentready</code> at the element level and <code>domready</code> at the DOM level)</li>
      <li>Keylistener utility that responds only when certain key combinations are detected.</li>
      <li>Focus/blur event abstraction layer that provides the ability to use deletegated listening techniques with these events.</li>
      <li>Custom events that are bubbleable, cancelable, and have intrinsic AOP qualities</li>
   </ul>
   
   
					<div class="yui-g">
						<div class="yui-u first">
							<div id="jumps">
								<h4>On This Page</h4>
								<ul>
									<li><a href="#start">Getting Started</a></li>
									<li><a href="#using">DOM Events</a></li>
									<li><a href="#removeevent">Removing Events</a></li>
                                    <li><a href="#eventsimulation">Simulating Events</a></li>
									<li><a href="#onavailable">Using the <code>available</code> and <code>contentready</code> Events (Formerly the <code>onAvailable</code> and <code>onContentReady</code> methods)</a></li>
									<li><a href="#ondomready">Using the <code>domready</code> Event (Formerly <code>onDOMReady</code>)</a></li>
									<li><a href="#keylistener">Using the <code>key</code> Event</a></li>
                                    <!--
									<li><a href="#focusblur">Using the <code>focus</code> and <code>blur</code> Events</a></li>
                                    -->
									<li><a href="#customevent">Using the CustomEvent Object</a></li>
									<li><a href="#support">Support &amp; Community</a></li>
									<li><a href="#filingbugs">Bug Reports &amp; Feature Requests</a></li>
								</ul>
							</div>
						</div>
						<div class="yui-u">
							<?php
							include('../inc/quicklinks.inc');
							?>
						</div>
					</div>				
					<div class="clear"></div>
				</div><!-- /promo -->

<?php include "../inc/gettingStarted.inc"; ?>

				
              <h3 id="domEvents">DOM Events</h3>
                <p>To attach an event handler to the DOM, simply define your event handler and pass the event handler to the Event Utility along with a reference to the event for which you want to listen and the element to which you want attach the handler: </p>
<pre><textarea name="code" class="JScript" cols="60" rows="1">
//the function we'll use to handle the event:
function handleClick(e) {
	//Pass the event facade to the logger or console for
    //inspection:
    Y.log(e);
}

//assuming we have an element on the page with an ID
//attribute "foo":
YUI().use('node', function(Y) {
    Y.on("click", handleClick, "#foo");
});</textarea></pre>

    <p>These lines of code:</p>
    <ul>
        <li>Create a YUI instance &mdash; Event Utility relies on <code>node</code>, so <code>Y.yui().use("node")</code> will load everything required to use the utility.</li>
        <li>Define a callback function, <code>handleClick(e)</code>, to handle  the specified
          event.</li>
        <li>Call the <code>on</code> method on the YUI instance (<code>Y</code>) to 
          bind an event to the DOM element. The <code>on</code> method requires three
          arguments: the event to bind (<code>"click"</code>, as a string), the callback function  (<code>handleClick</code>), and the element the event is bound to (<code>"#foo"</code>, assuming an element whose ID attribute is <code>foo</code>).</li>
  </ul>
    <p>Because we are identifying the element by its HTML ID (<code>"#foo"</code> as a string) rather than by passing in a Node instance or a direct HTMLElement reference, it is possible to refer to an element that does not yet exist on the page. The Event Utility attempts to find the DOM element by its <code>id</code> value; should it fail to find the element immediately, it continues to seek the element for up to 15 seconds after the page has loaded. This "automatic deferral" enables you, in some cases, to write your event attachment code directly into your script rather than separating it out in a function that runs only after the page has loaded.</p>
   
    <p>To attach an event handler to multiple elements, use CSS selector syntax (as above) that selects multiple elements, pass in multiple selector strings as an array, pass in an array of Node instances, or pass in an array of direct element references:</p>

<pre><textarea name="code" class="JScript" cols="60" rows="1">YUI().use('node', function(Y) {

    //elements can be targeted using selector syntax:
    Y.on("click", handleClick, "#foo p"); //targets all p elements that are descendants
                                          //of #foo
                                          
    //elements can be targeted by Node references:
    var foo = Y.Node.get("#foo");
    Y.on("click", handleClick, foo);
    foo.on("click", handleClick); //same as above

    //elements can be passed in as direct references:
    var foo = document.getElementById("foo");
    Y.on("click", handleClick, foo);

    //In all cases, you can pass in an array instead of a
    //single item:
    Y.on("click", handleClick, ["#foo p", "#bar"]);
});</textarea></pre>
<h4 id="on">Using <code>on</code>: Controlling Context and Arguments</h4>

<p>When you call <code>Y.on</code>, you have the following arguments to work with:</p>
<ol>
  <li><strong>Event name:</strong> This is the string reference to the DOM event to which you want to respond (e.g., &quot;<code>click</code>&quot; or &quot;<code>mouseover</code>&quot;). Developers often wonder where they can find a comprehensive list of DOM events that shows in which browsers each event is supported. As far as we know, no perfect list exists.  Danny Goodman's <em><a href="http://www.oreillynet.com/catalog/9780596527402/">DHTML: The Definitive Reference</a></em> may have the most comprehensive information of this kind; PPK's <a href="http://www.quirksmode.org/js/events_compinfo.html">Event Compatibility Table</a> on quirksmode may have the best compatibility assessment online.  The Event Utility does not place any constraints on the events for which you attach handlers; it will attempt to attach listeners for any event name you provide.  It's your responsibility to make sure that the event you're using is one that is supported in the browsers for which you're developing.</li>
  <li><strong>Handler: </strong>A reference to the function that should be called when the specified event takes place.</li>
  <li><strong>Element(s):</strong> As noted above, this can be one or more elements referenced using selector syntax, Node instances, or direct element references.</li>
  <li><strong>Context object:</strong> A reference to the object that will provide the context for the event handler &mdash; the object to which <code>this</code> will refer when the handler executes. If this is omitted, the context object will be a Node instance based on the target element.</li>
  <li><strong>Argument 1 ... <em>n</em>:</strong> The fifth thru <em>n</em>th arguments passed to on will be passed to the event handler.</li>
  </ol>
  
<p>The following code shows these arguments in use.  HTML:</p>

<textarea name="code" class="HTML" cols="60" rows="1"><div id="list">
	<ul>
		<li id="one" class="odd">Item one</li>
        <li id="two" class="even">Item two</li>
	    <li id="three" class="odd">Item three</li>
	    <li id="four" class="even">Item four</li>
	</ul>
</div></textarea>

<p>Script:</p>

<textarea name="code" class="JScript" cols="60" rows="1">//Create YUI instance:
YUI().use("dump", "node", function(Y) {

    //create arbitrary context object:
    var contextObj = {
        name: "context"
    };

    //function to handle click events and report information about them:
    function handleClick(e, arg1, arg2) {
        Y.log("Context object:" + Y.dump(this));
        Y.log("Event facade object:" + Y.dump(e));
        Y.log(arguments);
    }

    //subscribe odd numbered list items to the click event
    Y.on("click", handleClick, "#list .odd", contextObj, "argumentOne", "argumentTwo");
});</textarea>

<p>When you run this code and click on "Item one" or "Item three", the following information will be sent to <code>Y.log</code>:</p>

<textarea name="code" class="JScript" cols="60" rows="1">Context object: {name => context}
Event facade object: {
	altKey => false, 
    cancelBubble => false, 
    ctrlKey => false, 
    //and remaining event facade properties
    ...}</textarea>
    
<p>The final object logged, the <code>arguments</code> object, will contain three items: <code>e</code> (the event facade), "argumentOne" (string), and "argumentTwo" (string).</p>


<h4>Legacy Methods: <code>Event.addListener</code> and <code>Event.on</code></h4>

<p>The Event Utility contains two legacy methods for attaching event listeners; these are located in the <code>Event</code> package and follow the syntax of the Event Utility from previous versions of YUI.  If you are writing code using YUI 3.x, you should avoid using these methods and instead use the syntax described above.</p>

<h3 id="removeevent">Removing Events</h3>

<p>There are two ways to remove an event listener:</p>
<ol>
  <li><strong>Call detach on the event's handle:</strong> The return value of on is an event handle object; that object contains a detach method that can be used to remove the event.</li>
  <li><strong>Call the YUI detach method, passing in event type, handler, and element:</strong> detach is available as a method on your YUI instance and can be used when you don't have access to the event handle.</li>
</ol>
<p>Sample code for each of these methods:</p>
<textarea name="code" class="JScript" cols="60" rows="1">//Get a YUI instance:
YUI().use('node', function(Y) {

    //an event handler:
    function handleClick(e) {
        Y.log(e);
    }

    //attach an event handler to element foo:
    var fooHandle = Y.on("click", handleClick, "#foo");

    //detach the handler using the handle:
    fooHandle.detach();

    //detach the handler via detach:
    Y.detach("click", handleClick, "#foo");

    //or pass the event handle to detach:
    Y.detach(fooHandle);
});</textarea>

<p><code>Event.purgeElement</code> lets you remove all listeners that were registered via <code>on</code> from an element. Optionally, a specific type of listener can be specified. In addition, The element's children can also be purged.
</p>
<textarea name="code" class="JScript" cols="60" rows="1">//get a YUI instance:
YUI().use('node', function(Y) {
    // purge all listeners:
    Y.Event.purgeElement("#foo");
    // all listeners and recurse children:
    Y.Event.purgeElement("#foo", true);
    // only click listeners, and don't recurse:
    Y.Event.purgeElement("#foo", false, "click");
});</textarea>

<h3 id="eventsimulation">Simulating Events</h2>
<p>Simulated events are browser-created events that, most of the time, behave exactly as user-initated events. Events bubble as they normally would
  and <code>event</code> objects are created with properties containing data about the event (sometimes these properties are browser-specific, so it's
  recommended that you make use of the browser-equalizing methods of <code>Y.Event</code> to retrieve the appropriate values for
  properties such as <code>target</code>, <code>relatedTarget</code>, and <code>charCode</code>. All event handlers are called synchronously
  at each event target throughout the event's lifetime. Events are simulated using the <code>Y.Event.simulate()</code> method.</p>  
<h4>Mouse Events</h4>
<p>There are seven mouse events that can be simulated using methods on <code>Y.Event</code>:</p>
<ul>
  <li>click</li>
  <li>dblclick</li>
  <li>mousedown</li>
  <li>mouseup</li>
  <li>mouseover</li>
  <li>mouseout</li>
  <li>mousemove</li>
</ul>
<p>Each event is fired by calling <code>Y.Event.simulate()</code> and passing in three arguments: the element to fire the event on,
the type of event to fire, and an optional object specifying additional information for the event. To simulate a click on the document's body element,
  for example, the following code can be used:</p>
<textarea name="code" class="JScript" cols="60" rows="1">
<script type="text/javascript">
    Y.Event.simulate(document.body, "click");
</script> 
</textarea>
<p>This code simulates a click with all of the default properties on the <code>event</code> object. To specify additional information,
  such as the Shift key being down, the second argument must be used and the exact DOM name for the event property specified (there is
  browser-normalizing logic that translates these into browser-specific properties when necessary):
<textarea name="code" class="JScript" cols="60" rows="1">
<script type="text/javascript">
    Y.Event.simulate(document.body, "click", { shiftKey: true });
</script> 
</textarea>  
<p>In this updated example, a click event is fired on the document's body while simulating that the Shift key is down.</p>
<p>The extra properties to specify vary depending on the event being simulated and are limited to this list:</p>
<ul>
  <li>detail - Indicates the number of times a button was clicked (DOM-compliant browsers only).</li>
  <li>screenX/screenY - coordinates of the mouse event in relation to the entire screen (DOM-compliant browsers only).</li>
  <li>clientX/clientY - coordinates of the mouse event in relation to the browser client area.</li>
  <li>ctrlKey/altKey/shiftKey/metaKey - the state of the Ctrl, Alt, Shift, and Meta keys, respectively (true for down, false for up).</li>
  <li>button - the button being used for the event, 0 for left (default), 1 for right, 2 for center.</li>
  <li>relatedTarget - the element the mouse moved from (during a mouseover event) or to (during a mouseout event). </li>
</ul>
<p>Examples of the different methods and their extra properties:</p>
<textarea name="code" class="JScript" cols="60" rows="1">
<script type="text/javascript">
    var element = document.getElementById("myDiv");
    
    //simulate a click Alt key down
    Y.Event.simulate(element, "click", { altKey: true});
    
    //simulate a double click with Ctrl key down
    Y.Event.simulate(element, "dblclick", { ctrlKey: true });
    
    //simulate a mouse over
    Y.Event.simulate(element, "mouseover", { relatedTarget: document.body });
    
    //simulate a mouse out
    Y.Event.simulate(element, "mouseout", { relatedTarget: document.body });
    
    //simulate a mouse down at point (100,100) in the client area
    Y.Event.simulate(element, "mousedown", { clientX: 100, clientY: 100 });
    
    //simulate a mouse up at point (100,100) in the client area
    Y.Event.simulate(element, "mouseup", { clientX: 100, clientY: 100 });
    
    //simulate a mouse move at point (200, 200) in the client area
    Y.Event.simulate(document.body, "mousemove", { clientX: 200, clientY: 200 });

</script> 
</textarea>
<h4>Key Events</h4>
<p>There are three key event simulations available using <code>UserAction</code>:</p>
<ul>
  <li>keyup</li>
  <li>keydown</li>
  <li>keypress</li>
</ul>
<p>As with the mouse events, key events are simulated using <code>Y.Event.simulate()</code>. For <code>keyup()</code> and <code>keydown()</code>, the <code>keyCode</code> 
  property must be specified; for <code>keypress()</code>, the <code>charCode</code> property must be included. In many cases,
  <code>keyCode</code> and <code>charCode</code> may be the same value to represent the same key (97, for instance, represents the &quot;A&quot;
  key as well as being the ASCII code for the letter &quot;a&quot;). For example:</p>
<textarea name="code" class="JScript" cols="60" rows="1">
<script type="text/javascript">
    var element = document.getElementById("myDiv");
    
    //simulate a keydown on the A key
    Y.Event.simulate(element, "keydown", { keyCode: 97 });

    //simulate a keyup on the A key
    Y.Event.simulate(element, "keyup", { keyCode: 97 });
    
    //simulate typing "a"
    Y.Event.simulate(element, "keypress", { charCode: 97 });    

</script> 
</textarea>
<p>Key events also support the <code>ctrlKey</code>, <code>altKey</code>, <code>shiftKey</code>, and <code>metaKey</code> event properties.</p>
<p><strong>Note:</strong> Due to differences in browser implementations, key events may not be simulated in the same manner across 
  all browsers. For instance, when simulating a keypress event on a textbox, only Firefox will update the textbox with the new character
  of the key that was simulated to be pressed. For other browsers, the events are still registered and all event handlers are called,
  however, the textbox display and <code>value</code> property are not updated. These differences should go away as browser support
  for simulated events improves in the future.</p>
<p><strong>Safari 2.x Developers:</strong> Due to a bug in the Safari 2.x codebase, simulating a keydown event may cause the browser to 
  crash. This issue has been resolved in Safari 3.x.</p>  

<h3 id="onavailable">Using the <code>available</code> and <code>contentready</code> events (Formerly the <code>onAvailable</code> and <code>onContentReady</code> methods)</h3>
<p><code>available</code> lets you define a function that will execute as soon as an element
  is detected in the DOM. The intent is to reduce the occurrence of timing issues
  when rendering script and html inline. It is not meant to be used to define
  handlers for elements that <em>may</em> eventually be in the document; it is meant to
  be used to detect elements you are in the process of loading.
</p>
<p>

The argument signature for <code>available</code> is illustrated here:</p>
  
<pre><textarea name="code" class="JScript" cols="60" rows="1">
 &lt;script type="text/javascript"&gt;
 
 YUI().use('node', function(Y) {

     function TestObj(id) {
       Y.on('available', this.handleOnAvailable, id, this); 
     }

     TestObj.prototype.handleOnAvailable = function(me) {
       Y.log(this.id + " is available");
     }

     var obj = new TestObj("myelementid");
 });
 &lt;/script&gt;

 &lt;div id="myelementid"&gt;my element&lt;/div&gt;

</textarea></pre>

<p>The <code>contentready</code> method shares an identical syntax with
<code>available</code>.  The material difference between the two methods is
that <code>contentready</code> waits until both the target element and its
<code>nextSibling</code> in the DOM respond to <code>getElementById</code>.
This guarantees that the target element's contents will have loaded fully
(excepting any dynamic content you might add later via script).  If
<code>contentready</code> never detects a <code>nextSibling</code>, it fires
with the <code>window.load</code> event.</p>

<h3 id="ondomready">Using the <code>domready</code> Event (Formerly <code>onDOMReady</code>)</h3>
<p>The <code>domready</code> custom event lets you define a function that
will execute as soon as the DOM is in a usable state.  The DOM is not deemed
"usable" until it is structurally complete; a number of bugs, primarily in IE,
can lead to the browser crashing or failing to load the page successfully if
scripts attempt to insert information into the DOM prior to the DOM being in a
complete state.</p>

<p>DOM readiness is achieved before images have finished loading, however, so
<code>domready</code> is often an excellent alternative to using the
<code>window</code> object's <code>load</code> event.</p>

<textarea name="code" class="JScript" cols="60" rows="1">
YUI().use('node', function(Y) {
     function init() {
        Y.Node.get("#hidden_element").set("visibility", "");
     }
     Y.on("domready", init);

     // As with all custom events, you can pass
     // a context object and arguments that will be
     // passed to your handlers:
     // Y.on("domready", init, contexObject, argumentOne, argumentTwo, argumentN);
});
</textarea>


<h3 id="keylistener">Using the <code>key</code> Event</h3>
<p>The <code>key</code> event lets you define a function that will execute only when
a certain key (or set of keys), with or without modifiers, is detected.</p>

<h4 id="creatingkeylistener">Creating a Key Listener</h4>
<p>The following will attach a keydown listener to an element with the id
of 'text1'.  The listener will only be exectued if the return key (keyCode
13) is detected, and the listener is remove the first time this key
is detected.</p>
<textarea name="code" class="JScript" cols="60" rows="1">

YUI().use('node', function(Y) {

    // store the return value from Y.on to remove the listener later
    var handle = Y.on('key', function(e, arg1, arg2, etc) {
        Y.log(e.type + ": " + e.keyCode + ' -- ' + arg1);

        // stopPropagation() and preventDefault()
        e.halt();

        // unsubscribe so this only happens once
        handle.detach();

    // Attach to 'text1', specify keydown, keyCode 13, make Y the context, add arguments
    }, '#text1', 'down:13', Y, "arg1", "arg2", "etc");

});

</textarea>

<h4 id="definespec">Defining a Key Listener Specification</h4>
<p>In the previous example, 'down:13' was provided as the key listener
specification.  This specifies that the lister should only fire if the
return key triggers a keydown event.  The specification string consists of 
three parts:
<ol>
<li>The key event type followed by a colon ('up:', 'down:, or 'press:')</li>
<li>zero or more keyCodes to listen for, separated by commas.  If more than one
keyCode is specified, the listener will fire if any of the codes are detected. ('up:12,13,14')</li>
<li>zero or more modifiers keys to listen for, separated by the plus symbol.  If modifiers are
specified, all must be detected in order for the listener to fire ('+shift+ctrl+alt+meta').</li>
</ol>
<p>So, the following specification will fire only if keyCode 65 or 66 is detected during a keypress event while shift and control
are held down: 'press:65,66+shift+ctrl'</p>


<h3 id="customevent">Using the CustomEvent Object </h3>
<p>The CustomEvent object enables you to define and use events beyond those available in the DOM &mdash; events that are specific to and of interest in your own application. Custom Events are designed to work much like DOM events.  They can bubble, pass event facades, have their propagation and default behaviors suppressed, etc.  This section describes several common uses of YUI Custom Events and provides some sample code.  It contains these sections: </p>
<ul>
<li> <a href="#customdefine">Defining a Custom Event </a></li>
<li> <a href="#customsubscribe">Subscribing (Listening) to a Custom Event </a></li>
<li><a href="#customfire">Firing the Event </a></li>
</ul>

<h4 id="customdefine">Defining a Custom Event</h4>
<p>The most common way to create a Custom Event is to <code>augment</code> an object with <code>Event.Target</code>, making it able to host Custom Events and be a target Custom Events that are bubbling from other hosts.: </p>
<textarea name="code" class="JScript" cols="60" rows="1">
//Create a YUI instance:
YUI().use('node', function(Y) {

    //Define a constructor:
    function Publisher() {
        //create a custom event:
        this.publish("publisher:testEvent");
    }
    //augment the Publisher with Event.Target:
    Y.augment(Publisher, Y.Event.Target);
});
</textarea>
<p>
The <code>publish</code> constructor creates a new Custom Event; it takes one required parameter and one optional parameters:
</p>
  
<ul>
<li><strong>type</strong> &mdash; The type of event. This string is returned to listeners
  that receive this event so that they know what event occurred.</li> 
 <li><strong>options</strong> &mdash; The specific configuration options you want to define for this Custom Event.  Most properties of the Custom Event class can be set at this time.</li>
 </ul>
<p>


<h3 id="customsubscribe">Subscribing (Listening) to a Custom Event</h3>
<p>To subscribe to a custom event, use its <code>subscribe</code> method.  Following the code above, you would subscribe to the <code>publisher:testEvent</code> as follows:</p>
<pre><textarea name="code" class="JScript" cols="60" rows="1">
var publisher = new Publisher();
publisher.subscribe("publisher:testEvent", function() {
	//event handler code
});
</textarea></pre>

<h4 id="customfire">Firing the Event</h4>
<p>To trigger or <code>fire</code> a custom event, simpy call its <code>fire</code> method:</p>

<pre><textarea name="code" class="JScript" cols="60" rows="1">
publisher.fire("publisher:testEvent");
</textarea></pre>

<?php include "../inc/mobileSection.inc";?>

<p>The Event Utility works in any browser that has DOM2 event support.
However, the user interaction model of mobile browsers can make certain browser
events behave in a different manner than expected, or not at all.</p>

<p>The iPhone's touch interface supports gestures that prevent
certain mouse events from working correctly.  For instance, the 'mousedown'
event does not fire when the user initially touches the screen over an element.
It only fires once the user's finger is removed (the mousedown, mouseup, and
click events all fire at this moment).  This makes is difficult or impossible
to provide certain DHTML interactions that rely on these events, drag and drop
being the most obvious.</p> 

<p>Since the iPhone has a touch interface, there is
no mouse cursor.  This means that there are no hover states for elements, and
no mouseover events.</p>

<?php 
include "../inc/support.inc";
?>

		</div>
<div class="yui-u sidebar">

	<?php 
	include "../inc/cheatsheet.inc";
	?>
			
			<div id="examples">
<?php 
	include("../inc/examplesNav/".$section.".inc");
?>
		   </div>
		   		   
		<!-- delicious module -->
		<?php require('../inc/mod-delicious.inc'); ?>
		<!-- /delicious module -->


		 </div>
      </div>

</div>
</div>

<?php include "../inc/side.inc" ?>
<?php include "../inc/footer.inc" ?>




